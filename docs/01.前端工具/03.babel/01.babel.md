---
title: Babel
date: 2022-04-22 14:13:23
permalink: /pages/b0b059/
---

## Babel

`Babel` 是一个工具链，主要用于将采用 `ECMAScript 2015+` 语法编写的代码转换为向后兼容的 `JavaScript 语法`，以便能够运行在当前和旧版本的浏览器或其他环境中。

我们一般用 Babel 做下面几件事：

- 语法转换（`es-higher` -> `es-lower`）;
- 通过 `Polyfill` 处理在目标环境无法转换的特性（通过 `core-js` 实现）;
- 源码转换（`codemods`、`jscodeshift`）;
- 静态分析（`lint`、根据注释生成 `API` 文档等）;

## 关于 Babel 版本

目前，前端开发领域使用的 Babel 版本主要的 Babel6 和 Babel7 这两个版本。

Babel 是一个工具集，而这个工具集是围绕@babel/core 这个核心 npm 包构成的。每次@babel/core 发布新版本的时候，整个工具集的其它 npm 包也都会跟着升级到与@babel/core 相同的版本号，即使它们的代码可能一行都没有改变。

Babel7 的 npm 包都是放在 babel 域下的，即在安装 npm 包的时候，我们是安装@babel/这种方式，例如@babel/cli、@babel/core 等。而在 Babel6，我们安装的包名是 babel-cli，babel-core 等。其实它们本质是一样的，都是 Babel 官方的 cli 命令行工具和 core 核心包，而且功能是一样的，只是名称版本变化了一下而已。在平时开发和学习的过程中，碰到'@babel/'和'babel-'应该下意识认识到他俩原本是一个包，只是版本不一样而已。

## Babel 配置文件

Babel 的配置文件是 Babel 执行时默认会在当前目录寻找的文件，主要有.babelrc，.babelrc.js，babel.config.js 和 package.json。它们的配置项都是相同，作用也是一样的，只需要选择其中一种。

对于.babelrc，它的配置是这样子

    {
        "presets": ["es2015", "react"],
        "plugins": ["transform-decorators-legacy", "transform-class-properties"]
    }

对于 babel.config.js 和.babelrc.js，它的配置是一样的，通过 module.exports 输出配置项

    module.exports = {
        "presets": ["es2015", "react"],
        "plugins": ["transform-decorators-legacy", "transform-class-properties"]
    }

对于 package.json，就是在 package.json 中增加一个 babel 属性和值，它的配置是这样子

    {
        "name": "demo",
        "version": "1.0.0",
        "description": "",
        "main": "index.js",
        "scripts": {
            "test": "echo \"Error: no test specified\" && exit 1"
        },
        "author": "",
        "babel": {
            "presets": ["es2015", "react"],
            "plugins": ["transform-decorators-legacy", "transform-class-properties"]
        }
    }

在 webpack 配置文件中，我们把 babel-loader 添加到 module 的 loaders 列表中：

    module: {
        rules: [
        {
            test: /\.js$/,
            exclude: /(node_modules|bower_components)/,
            use: {
            loader: 'babel-loader',
            options: {
                presets: ['@babel/preset-env']
            }
            }
        }
        ]
    }

在这里，我们通过 options 属性给 babel-loader 传递预设和插件等 Babel 配置项。我们也可以省略这个 options，这个时候 babel-loader 会去读取默认的 Babel 配置文件，也就是.babelrc，.babelrc.js，babel.config.js 等。在现在的前端开发中，建议通过配置文件来传递这些配置项。

## 插件与预设

plugin 代表插件，preset 代表预设，它们分别放在 plugins 和 presets，每个插件或预设都是一个 npm 包。

plugins 插件数组和 presets 预设数组是有顺序要求的。如果两个插件或预设都要处理同一个代码片段，那么会根据插件和预设的顺序来执行。规则如下

- 插件比预设先执行
- 插件执行顺序是插件数组从前向后执行
- 预设执行顺序是预设数组从后向前执行

### preset 预设的选择

在 Babel6 的时代 ,很复杂,一言难尽 ,现在只需一个`@babel/preset-env`就可以了

在实际开发过程中，除了使用@babel/preset-env 对标准的 ES6 语法转换，我们可能还需要类型检查和 react 等预设对特定语法转换。这里有三个官方预设可以使用：

    * @babel/preset-flow
    * @babel/preset-react
    * @babel/preset-typescript

总结起来，Babel 官方的 preset，我们实际可能会用到的其实就只有 4 个：

    * @babel/preset-env
    * @babel/preset-flow
    * @babel/preset-react
    * @babel/preset-typescript

一个普通的 vue 工程，Babel 官方的 preset 只需要配一个"@babel/preset-env"就可以了

#### @babel/preset-env

在 Babel6 时代，这个预设名字是 babel-preset-env，在 Babel7 之后，改成@babel/preset-env。除了进行语法转换，该预设还可以通过设置参数项进行针对性语法转换以及 polyfill 的按需引入

在使用它之前，需要先安装

     npm install --save-dev @babel/core @babel/cli @babel/preset-env

以 babel.config.js 为例,对于 preset，当我们不需要对其设置参数的时候

    module.exports = {
        presets: ["@babel/preset-env"],
        plugins: []
    }

**targets** 该参数项可以取值为字符串、字符串数组或对象，默认{},targets > browserslist(都没设置 全部 es6=>es5)

    module.exports = {
        presets: [["@babel/env", {
        targets: {
            "chrome": "58",
            "ie": "11"
        },
        "useBuiltIns": "usage",
        "corejs": 3
        }]],
        plugins: []
    }

**useBuiltIns** 默认值 false

        usage：每个文件引用使用到的特性；
        false：不引入,如果 引入 @babel/polyfill 则全引入
        entry：全部引入,需要 入口文件
               import "core-js/stable";
               import "regenerator-runtime/runtime";


**corejs** 默认值 2,只有 useBuiltIns 设置为'usage'或'entry'时，才会生效
2 对应 core-js@2 ,3 对应 core-js@3(目前多用的是 3)

ps:Browserslist 叫做目标环境配置表，除了写在 package.json 里，也可以单独写在工程目录下.browserslistrc 文件里。我们用 browserslist 来指定代码最终要运行在哪些浏览器或 node.js 环境。Autoprefixer、postcss 等就可以根据我们的 browserslist，来自动判断是否要增加 CSS 前缀（例如'-webkit-'）。我们的 Babel 也可以使用 browserslist，如果你使用了@babel/preset-env 这个预设，此时 Babel 就会读取 browserslist 的配置。

如果我们的@babel/preset-env 不设置任何参数，Babel 就会完全根据 browserslist 的配置来做语法转换。如果没有 browserslist，那么 Babel 就会把所有 ES6 的语法转换成 ES5 版本。

#### Babel6 到 Babel7 的升级

* 废弃了 stage-x 和 es20xx 的 preset，改成 preset-env 和 plugin-proposal-xx；这样能更好地控制需要支持的特性；

* `preset-env` 依赖 `browserslist`, `compat-table`, and `electron-to-chromium` 实现了特性的精细按需引入。

##### compat-table  这个库维护着每个特性在不同环境的支持情况

### plugin 插件的选择

虽然 Babel7 官方有 90 多个插件，不过大半已经整合在@babel/preset-env 和@babel/preset-react 等预设里了，我们在开发的时候直接使用预设就可以了。

目前比较常用的插件只有@babel/plugin-transform-runtime。

1.自动移除语法转换后内联的辅助函数

2.当代码里使用了 core-js 的 API，自动引入@babel/runtime-corejs3/core-js-stable/，以此来替代全局引入的 core-js/stable;

3.当代码里使用了 Generator/async 函数，自动引入@babel/runtime/regenerator，以此来替代全局引入的 regenerator-runtime/runtime

`作用2和3其实是在做API转换，对内置对象进行重命名，以防止污染全局环境。`

引入'babel-polyfill'或'core-js/stable 与 regenerator-runtime/runtime'来做全局的 API 补齐。但这样可能有一个问题，那就是对运行环境产生了污染。例如 Promise，我们的 polyfill 是`对浏览器的全局对象进行了重新赋值，我们重写了Promise及其原型链`,会对浏览器环境产生污染（即修改了浏览器的 window.Promise）。

例子

Babel 转换前的代码

    var obj = Promise.resolve();

若使用了'babel-polyfill'或'core-js/stable 与 regenerator-runtime/runtime'来做全局的 API 补齐，那么 Babel 转换后的代码仍然是

    var obj = Promise.resolve();

polyfill 只是补齐了浏览器的 window.Promise 对象。

若我们不使用 polyfill，而开启@babel/plugin-transform-runtime 的 API 转换功能。那么 Babel 转换后的代码将是

    var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
    var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));
    var obj = _promise["default"].resolve();

@babel/plugin-transform-runtime 把我们代码里的 Promise 变成了\_promise["default"]，而\_promise["default"]拥有 ES 标准里 Promise 所有的功能。现在，即使浏览器没有 Promise，我们的代码也能正常运行。

`API转换有什么用，明明通过polyfill补齐API的方式也可以使代码在浏览器正常运行？`

API 转换主要是给开发 JS 库或 npm 包等的人用的，我们的前端工程一般仍然使用 polyfill 补齐 API。

`@babel/runtime包提供辅助函数模块,他的的进化版@babel/runtime-corejs3`

如果我们使用@babel/plugin-transform-runtime 来做 polyfill 的事情，那么就不要再使用之前讲过的 polyfill 方式了，无论是单独引入还是@babel/preset-env 的方式。因为我们用 transform-runtime 来做 api 转换的目的是不污染全局作用域。

默认值

    {
        "plugins": [
            [
                "@babel/plugin-transform-runtime",
                {
                    "helpers": true, 否要自动引入辅助函数包
                    "corejs": false, corejs取值是false、2和3 开发JS库的时候设为2和3
                    "regenerator": true, corejs和regenerator 两项 是否做API转换以避免污染全局环境
                    "useESModules": false, 是否使用ES6的模块化用法,在用webpack一类的打包工具的时候，可以设置为true，以便做静态分析
                    "absoluteRuntime": false,
                    "version": "7.0.0-beta.0"
                }
            ]
        ]
    }

PS:每个转换后的文件上部都会注入这些相同的函数声明，那为何不用 webpack 一类的打包工具去掉重复的函数声明，而是要单独再引一个辅助函数包？

webpack 在构建的时候，是基于模块来做去重工作的。每一个函数声明都是引用类型，在堆内存不同的空间存放，缺少唯一的地址来找到他们。所以 webpack 本身是做不到把每个文件的相同函数声明去重的。因此我们需要单独的辅助函数包，这样 webpack 打包的时候会基于模块来做去重工作。

#### babel 共有3种插件：

1.`babel-plugin-transform-xx`：转换插件，主要用来加强转换能力；

2.`babel-plugin-syntax-xx`：语法插件，主要是扩展编译能力，比如不在 async 函数作用域里面使用 await，如果不引入` @babel/plugin-syntax-top-level-await`，是没办法编译成 AST 树的。并且会报 Unexpected reserved word 'await' 这种类似的错误。

3.`babel-plugin-proposal-xx`：用来编译和转换在提案中的属性，在 Plugins List 中可以看到这些插件，比如 `class-properties`、`decorators`。

### @babel/polyfill

Babel 官方的 polyfill 使用方法主要有如下几种

1.直接在 html 文件引入 Babel 官方的 polyfill.js 脚本文件；

2.在前端工程的入口文件里引入 polyfill.js； 

3.在前端工程的入口文件里引入@babel/polyfill；

4.在前端工程的入口文件里引入 core-js/stable 与 regenerator-runtime/runtime；

5.在前端工程构建工具的配置文件入口项引入 polyfill.js； 

6.在前端工程构建工具的配置文件入口项引入@babel/polyfill； 

7.在前端工程构建工具的配置文件入口项引入 core-js/stable 与 regenerator-runtime/runtime；

从 babel7.4 开始，官方不推荐再使用@babel/polyfill 了，因为@babel/polyfill 本身其实就是两个 npm 包的集合：core-js 与 regenerator-runtime。

官方推荐直接使用这两个 npm 包。虽然@babel/polyfill 还在进行版本升级，但其使用的 core-js 包为 2.x.x 版本，而 core-js 这个包本身已经发布到了 3.x.x 版本了，@babel/polyfill 以后也不会使用 3.x.x 版本的包了。新版本的 core-js 实现了许多新的功能，例如数组的 includes 方法,所以现在直接配置@babel/preset-env，useBuiltIns usage

目前前端需要的配置

    {
        "presets": [
            [
                "@babel/preset-env",
                {
                    // 描述您为项目支持/目标的环境
                    "targets": {
                        "browsers": ["> 1%", "last 2 versions"]
                    },
                    "corejs": 3, //新版本需要指定核⼼库版本
                    "useBuiltIns": "usage", //按需注⼊
                    "modules": false
                }
            ]
        ],
        "plugins":[
            "@babel/transform-runtime"
        ]
    }

如果写个插件 参考`不可多得的 Babel 小抄`

参考：

[不可多得的 Babel 小抄](https://mp.weixin.qq.com/s/lVd-kXDUH7kSwkYQEvQO4Q)

[babel](https://www.jiangruitao.com/babel/babel-node/)
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基础 | 前端小册</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="个人知识笔记">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.6e60c68c.css" as="style"><link rel="preload" href="/assets/js/app.c3eaab60.js" as="script"><link rel="preload" href="/assets/js/2.0d541d74.js" as="script"><link rel="preload" href="/assets/js/5.20cfe6af.js" as="script"><link rel="prefetch" href="/assets/js/10.945953ec.js"><link rel="prefetch" href="/assets/js/11.fdd192f9.js"><link rel="prefetch" href="/assets/js/12.f930e6cf.js"><link rel="prefetch" href="/assets/js/13.83f7fdb4.js"><link rel="prefetch" href="/assets/js/14.d1f6a6d2.js"><link rel="prefetch" href="/assets/js/15.a3fc3a4c.js"><link rel="prefetch" href="/assets/js/16.1af45818.js"><link rel="prefetch" href="/assets/js/17.34452123.js"><link rel="prefetch" href="/assets/js/18.c2709a46.js"><link rel="prefetch" href="/assets/js/19.eda02219.js"><link rel="prefetch" href="/assets/js/20.21e22d86.js"><link rel="prefetch" href="/assets/js/21.0a21f463.js"><link rel="prefetch" href="/assets/js/22.ed465c56.js"><link rel="prefetch" href="/assets/js/23.92728309.js"><link rel="prefetch" href="/assets/js/24.a934b340.js"><link rel="prefetch" href="/assets/js/25.f19a7630.js"><link rel="prefetch" href="/assets/js/3.c3295fe2.js"><link rel="prefetch" href="/assets/js/4.eec9b412.js"><link rel="prefetch" href="/assets/js/6.3fdbcc80.js"><link rel="prefetch" href="/assets/js/7.7429f292.js"><link rel="prefetch" href="/assets/js/8.8bafbea7.js"><link rel="prefetch" href="/assets/js/9.a3529f32.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6e60c68c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200409124835.png" alt="前端小册" class="logo"> <span class="site-name can-hide">前端小册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="HTML" class="dropdown-title"><!----> <span class="title" style="display:;">HTML</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/925544/" class="nav-link">基础语法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="CSS" class="dropdown-title"><!----> <span class="title" style="display:;">CSS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/1687ff/" class="nav-link">基础语法</a></li></ul></div></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">JS</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工具" class="dropdown-title"><!----> <span class="title" style="display:;">前端工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/5d396b/" class="nav-link">前端需要掌握的命令行</a></li><li class="dropdown-item"><!----> <a href="/pages/52d5c3/" class="nav-link">git扫盲</a></li><li class="dropdown-item"><!----> <a href="/pages/b0b059/" class="nav-link">Babel</a></li><li class="dropdown-item"><!----> <a href="/pages/631196/" class="nav-link">Rollup</a></li></ul></div></div><div class="nav-item"><a href="/pages/c7313b/.html" class="nav-link">Node</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><!----> <span class="title" style="display:;">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/c7313b/" aria-current="page" class="nav-link router-link-exact-active router-link-active">React</a></li><li class="dropdown-item"><!----> <a href="/pages/eb039d/" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><a href="/pages/19ad2a/" class="nav-link">数据结构与算法</a></div> <a href="https://github.com/erdang/erdang.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="HTML" class="dropdown-title"><!----> <span class="title" style="display:;">HTML</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/925544/" class="nav-link">基础语法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="CSS" class="dropdown-title"><!----> <span class="title" style="display:;">CSS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/1687ff/" class="nav-link">基础语法</a></li></ul></div></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">JS</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工具" class="dropdown-title"><!----> <span class="title" style="display:;">前端工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/5d396b/" class="nav-link">前端需要掌握的命令行</a></li><li class="dropdown-item"><!----> <a href="/pages/52d5c3/" class="nav-link">git扫盲</a></li><li class="dropdown-item"><!----> <a href="/pages/b0b059/" class="nav-link">Babel</a></li><li class="dropdown-item"><!----> <a href="/pages/631196/" class="nav-link">Rollup</a></li></ul></div></div><div class="nav-item"><a href="/pages/c7313b/.html" class="nav-link">Node</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><!----> <span class="title" style="display:;">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/c7313b/" aria-current="page" class="nav-link router-link-exact-active router-link-active">React</a></li><li class="dropdown-item"><!----> <a href="/pages/eb039d/" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><a href="/pages/19ad2a/" class="nav-link">数据结构与算法</a></div> <a href="https://github.com/erdang/erdang.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c7313b/" aria-current="page" class="active sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/c7313b/#起步" class="sidebar-link">起步</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/c7313b/#使用第三方组件" class="sidebar-link">使用第三方组件</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#使用eslint-prettier来统一前端代码风格" class="sidebar-link">使用ESLint+Prettier来统一前端代码风格</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#cra-文件结构" class="sidebar-link">cra ⽂件结构</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#入口文件定义-webpack-config-js" class="sidebar-link">⼊口文件定义，webpack.config.js</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#react-和-reactdom" class="sidebar-link">React 和 ReactDom</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#jsx-语法" class="sidebar-link">JSX 语法</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#setstate" class="sidebar-link">setState</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/c7313b/#关于-setstate-你应该了了解三件事" class="sidebar-link">关于 setState() 你应该了了解三件事:</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/c7313b/#react-v16-3-之前的生命周期" class="sidebar-link">React V16.3 之前的生命周期</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#react-v16-4-之后的生命周期" class="sidebar-link">React V16.4 之后的生命周期</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#render" class="sidebar-link">render()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#constructor" class="sidebar-link">constructor()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#componentdidmount" class="sidebar-link">componentDidMount()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#componentdidupdate" class="sidebar-link">componentDidUpdate()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#componentwillunmount" class="sidebar-link">componentWillUnmount()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#shouldcomponentupdate" class="sidebar-link">shouldComponentUpdate()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#static-getderivedstatefromprops" class="sidebar-link">static getDerivedStateFromProps()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#getsnapshotbeforeupdate" class="sidebar-link">getSnapshotBeforeUpdate()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#static-getderivedstatefromerror" class="sidebar-link">static getDerivedStateFromError()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#componentdidcatch" class="sidebar-link">componentDidCatch()</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#事件处理" class="sidebar-link">事件处理</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#条件渲染-列表-key" class="sidebar-link">条件渲染 列表 &amp; Key</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#表单" class="sidebar-link">表单</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#组件-组件复合" class="sidebar-link">组件 组件复合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/c7313b/#class-组件" class="sidebar-link">class 组件</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#function-组件" class="sidebar-link">function 组件</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#复合" class="sidebar-link">复合</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#高阶组件" class="sidebar-link">高阶组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/c7313b/#链式调用" class="sidebar-link">链式调用</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#装饰器" class="sidebar-link">装饰器</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#react-createelement-与-react-cloneelement" class="sidebar-link">React.createElement() 与 React.cloneElement()</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#purecomponent" class="sidebar-link">PureComponent</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#react-memo" class="sidebar-link">React.memo</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#fragments" class="sidebar-link">Fragments</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#context-组件跨层级通信" class="sidebar-link">Context 组件跨层级通信</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#refs-and-the-dom" class="sidebar-link">Refs and the DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/c7313b/#react-forwardref" class="sidebar-link">React.forwardRef</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#portals" class="sidebar-link">Portals</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#render-props" class="sidebar-link">Render Props</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#strictmode" class="sidebar-link">StrictMode</a></li><li class="sidebar-sub-header"><a href="/pages/c7313b/#proptypes" class="sidebar-link">PropTypes</a></li></ul></li><li><a href="/pages/da5329/" class="sidebar-link">hook</a></li><li><a href="/pages/1d826c/" class="sidebar-link">rotuer</a></li><li><a href="/pages/de3feb/" class="sidebar-link">redux</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/eb039d/" class="sidebar-link">基础</a></li></ul></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><span data-v-1cd794fe>前端框架</span></li> <li data-v-1cd794fe><span data-v-1cd794fe>React</span></li> <!----></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/erdang" target="_blank" title="作者" class="beLink" data-v-1cd794fe>Er Dang</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-10-09</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">
          基础
        </h1>  <div class="theme-vdoing-content content__default"><h2 id="起步"><a href="#起步" class="header-anchor">#</a> 起步</h2> <ol><li>创建项目 npx create-react-app myapp</li> <li>打开项目: cd my-app</li> <li>启动项目: npm start</li> <li>暴露配置项: npm run eject 此方法不可逆</li></ol> <h3 id="使用第三方组件"><a href="#使用第三方组件" class="header-anchor">#</a> 使用第三方组件</h3> <ul><li>安装: npm install antd --save</li> <li>配置按需加载</li></ul> <p>通过react脚手架create-react-app创建了项目，但是发现了一个问题 如果没有执行eject命令的话 是没有其他配置文件的 这个时候就需要 用到 customize-cra 和 react-app-rewired插件
然后在根目录下新建一个名称为config-overrides.js的文件。在里面去进行所有的配置</p> <p><code>react-app-rewired的作用就是在不eject的情况下,覆盖create-react-app的配置</code></p> <p>babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件
//引入
const { injectBabelPlugin } =require('react-app-rewired');
//使用
module.exports =function override(config, env){
config= injectBabelPlugin(['import',
{ libraryName:'antd', style:true}],config);
return config;
};</p> <p>安装 react-app-rewired 取代 react-scripts，可扩展 webpack 的配置 ，类似 vue.config.js</p> <div class="language- extra-class"><pre><code>npm install react-app-rewired customize-cra babel-plugin-import -D

 //根目录创建config-overrides.js
const { override, fixBabelImports } = require(&quot;customize-cra&quot;);
module.exports = override(
fixBabelImports(&quot;import&quot;, {
    libraryName: &quot;antd&quot;,
    libraryDirectory: &quot;es&quot;,
    style: &quot;css&quot;
}) );

//修改package.json 
&quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-app-rewired start&quot;,
    &quot;build&quot;: &quot;react-app-rewired build&quot;,
    &quot;test&quot;: &quot;react-app-rewired test&quot;,
    &quot;eject&quot;: &quot;react-app-rewired eject&quot;
},
</code></pre></div><ul><li><p>使用组件</p> <p>import {Button} from 'antd'</p></li> <li><p>使用sass</p> <p>安装 npm install  node-sass --save-dev</p></li></ul> <p>因为create-react-app已经默认已经添加了scss/sass对应的loader，所以在安装完之后就可以在项目中使用scss了，详见配置可以参考\node_modules\react-scripts。</p> <ul><li>全局配置scss变量/函数</li></ul> <p>在用scss预处理器的时候，会常用变量/函数/混合等功能。目前如果想要使用变量/函数的话需要在每个文件中单独引入，这样明显不合理，我们需要的是引入一次，所以我们就需要定义全局主题的样式变量，也就是利用sass-resources-loader这个loader将scss变量打包到每个文件中。首先我们要安装sass-resources-loader。</p> <div class="language- extra-class"><pre><code>npm install --save-dev sass-resources-loader
</code></pre></div><p>不暴露配置文件情况下配置</p> <div class="language- extra-class"><pre><code>const { override, adjustStyleLoaders } = require(&quot;customize-cra&quot;);
module.exports = override(
// ...其他配置...
    adjustStyleLoaders(rule =&gt; {
        if (rule.test.toString().includes(&quot;scss&quot;)) {
        rule.use.push({
            loader: require.resolve(&quot;sass-resources-loader&quot;),
            options: {
            resources: &quot;./src/assets/scss/output.scss&quot; //这里是你自己放公共scss变量的路径
            }
        });
        }
})
);
</code></pre></div><h3 id="使用eslint-prettier来统一前端代码风格"><a href="#使用eslint-prettier来统一前端代码风格" class="header-anchor">#</a> 使用ESLint+Prettier来统一前端代码风格</h3> <p>编辑器vscode，并且已经安装好eslint和prettier插件
ESLint 进行代码的校验 Prettier 保持代码风格统一</p> <p>npm i -D prettier  新建.eslintrc.js并在package.json里面删除eslintConfig</p> <p>配合ESLint检测代码风格 npm i -D eslint-plugin-prettier</p> <p>eslint-plugin-prettier插件会调用prettier对你的代码风格进行检查，其原理是先使用prettier对你的代码进行格式化，然后与格式化之前的代码进行对比，如果过出现了不一致，这个地方就会被prettier进行标记。</p> <p>接下来，我们需要在rules中添加，&quot;prettier/prettier&quot;: &quot;error&quot;，表示被prettier标记的地方抛出错误信息</p> <div class="language- extra-class"><pre><code>//.eslintrc.js
{
&quot;plugins&quot;: [&quot;prettier&quot;],
&quot;rules&quot;: {
    &quot;prettier/prettier&quot;: &quot;error&quot;
}
}
</code></pre></div><p>如果与已存在的插件冲突怎么办</p> <p>npm i -D eslint-config-prettier</p> <p>通过使用eslint-config-prettier配置，能够关闭一些不必要的或者是与prettier冲突的lint选项。这样我们就不会看到一些error同时出现两次。使用的时候需要确保，这个配置在extends的最后一项</p> <div class="language- extra-class"><pre><code>//.eslintrc.js
{
    extends: [
        'standard', //使用standard做代码规范
        &quot;plugin:prettier/recommended&quot;,
        &quot;prettier&quot;,
    ],

}
</code></pre></div><p>新建.prettierrc.js并添加</p> <div class="language- extra-class"><pre><code>{
semi: true,
trailingComma: 'all',
singleQuote: true,
printWidth: 120,
tabWidth: 4,
}
</code></pre></div><p>添加commit命令 npm install --save lint-staged husky
修改package.json</p> <div class="language- extra-class"><pre><code>&quot;lint-staged&quot;: {
    &quot;*.+(js|jsx)&quot;: [
        &quot;eslint --fix&quot;,
        &quot;git add&quot;
    ],
    &quot;*.+(json|css|md)&quot;: [
        &quot;prettier --write&quot;,
        &quot;git add&quot;
    ]
},
&quot;husky&quot;: {
    &quot;hooks&quot;: {
        &quot;pre-commit&quot;: &quot;lint-staged&quot;
    }
},
</code></pre></div><h3 id="cra-文件结构"><a href="#cra-文件结构" class="header-anchor">#</a> cra ⽂件结构</h3> <div class="language- extra-class"><pre><code>├── README.md             文档
├── public                静态资源
│ ├── favicon.ico
│ ├── index.html
│ └── manifest.json
└── src                   源码
├── App.css
├── App.js                根组件
├── App.test.js
├── index.css             全局样式
├── index.js              入⼝文件
├── logo.svg
└── serviceWorker.js      pwa 支持
├── package.json          npm 依赖
</code></pre></div><h3 id="入口文件定义-webpack-config-js"><a href="#入口文件定义-webpack-config-js" class="header-anchor">#</a> ⼊口文件定义，webpack.config.js</h3> <div class="language- extra-class"><pre><code>entry: [
// WebpackDevServer 客户端，它实现开发时热更更新功能
isEnvDevelopment &amp;&amp; require.resolve('react-dev-utils/webpackHotDevClient'),
// 应⽤用程序⼊入⼝口:src/index
paths.appIndexJs,
].filter(Boolean),
</code></pre></div><p>webpack.config.js 是 webpack 配置⽂文件，开头的常量量声明可以看出 cra 能够⽀支持 ts、sass 及 css 模块化</p> <div class="language- extra-class"><pre><code>// Check if TypeScript is setup
const useTypeScript = fs.existsSync(paths.appTsConfig);
// style files regexes
const cssRegex = /\.css$/;
const cssModuleRegex = /\.module\.css$/;
const sassRegex = /\.(scss|sass)$/;
const sassModuleRegex = /\.module\.(scss|sass)$/;
</code></pre></div><h3 id="react-和-reactdom"><a href="#react-和-reactdom" class="header-anchor">#</a> React 和 ReactDom</h3> <div class="language- extra-class"><pre><code>import React from 'react';
import ReactDOM from 'react-dom';
// 这⾥里里怎么没有出现React字眼?
// JSX =&gt; React.createElement(...)
ReactDOM.render(&lt;h1&gt;Hello React&lt;/h1&gt;, document.querySelector('#root'));
React负责逻辑控制，数据 -&gt; VDOM
ReactDom渲染实际DOM VDOM -&gt; DOM
React使⽤用JSX来描述UI
babel-loader把JSX 编译成相应的 JS 对象，
React.createElement再把这个JS对象构造成React需 要的虚拟dom。
</code></pre></div><h3 id="jsx-语法"><a href="#jsx-语法" class="header-anchor">#</a> JSX 语法</h3> <p>JSX 是一种 JavaScript 的语法扩展，其格式比较像模版语言，但事实上完全 是在 JavaScript 内部实现的。
<br>
JSX 可以很好地描述 UI，能够有效提高开发效率，体验 <a href="https://zh-hans.reactjs.org/" target="_blank" rel="noopener noreferrer">JSX<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="基本使用"><a href="#基本使用" class="header-anchor">#</a> 基本使用</h4> <p>表达式{}的使用，index.js</p> <div class="language- extra-class"><pre><code>const name = &quot;react study&quot;;
const jsx = &lt;div&gt;hello, {name}&lt;/div&gt;;
</code></pre></div><h4 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h4> <p>函数也是合法表达式，index.js</p> <div class="language- extra-class"><pre><code>const user = {
    fistName: &quot;Harry&quot;,
};
function formatName(name) {
    return name.fistName + &quot; &quot; + name.lastName;
}
const jsx = &lt;div&gt;{formatName(user)}&lt;/div&gt;;
</code></pre></div><h4 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h4> <p>jsx 是 js 对象，也是合法表达式，index.js</p> <div class="language- extra-class"><pre><code>const greet = &lt;div&gt;good&lt;/div&gt;;
const jsx = &lt;div&gt;{greet}&lt;/div&gt;;
</code></pre></div><h4 id="条件语句"><a href="#条件语句" class="header-anchor">#</a> 条件语句</h4> <p>条件语句可以基于上面结论实现，index.js</p> <div class="language- extra-class"><pre><code>const show = true;//false;
const greet = &lt;div&gt;good&lt;/div&gt;;
const jsx = (
&lt;div&gt;
// 条件语句
{show ? greet : &quot;登录&quot;} {show &amp;&amp; greet}
&lt;/div&gt;
);
</code></pre></div><h4 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h4> <p>数组会被作为一组子元素对待，数组中存放一组 jsx 可用于显示列表数据</p> <div class="language- extra-class"><pre><code>const a = [0, 1, 2];
const jsx = (
&lt;div&gt;
 //数组
  &lt;ul&gt;
//diff 时候，首先比较 type，然后是 key，所以同级同类型元素， key 值必须得 唯一
{a.map(item =&gt; (
&lt;li key={item}&gt;{item}&lt;/li&gt;
))}
&lt;/ul&gt; &lt;/div&gt;
);
</code></pre></div><h4 id="属性的使用"><a href="#属性的使用" class="header-anchor">#</a> 属性的使用</h4> <div class="language- extra-class"><pre><code>import logo from &quot;./logo.svg&quot;;

const jsx=(
    &lt;img src={logo} style={{ width: &quot;100px&quot; , height:&quot;100px&quot;,background:&quot;#000&quot;} className=&quot;img&quot;/&gt;
)
</code></pre></div><h4 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h4> <p>css 模块化，创建 index.module.css，index.js</p> <div class="language- extra-class"><pre><code>import style from &quot;./index.module.css&quot;;
&lt;img className={style.logo} /&gt;
</code></pre></div><p>或者 npm install sass -D</p> <div class="language- extra-class"><pre><code>import style from &quot;./index.module.scss&quot;;
&lt;img className={style.logo} /&gt;
</code></pre></div><h2 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h2> <p>setState(partialState, callback)</p> <ol><li>partialState:object|function
<br>
⽤于产⽣与当前 state 合并的子集。</li> <li>callback:function
<br>
state 更更新之后被调⽤用。</li></ol> <h3 id="关于-setstate-你应该了了解三件事"><a href="#关于-setstate-你应该了了解三件事" class="header-anchor">#</a> 关于 setState() 你应该了了解三件事:</h3> <p>1.不要直接修改 State</p> <div class="language- extra-class"><pre><code>//此代码不会重新渲染组件:
this.state.name='erdang'
//正确
this.setState({name:'erdang'})
</code></pre></div><p>2.State 的更更新会被合并</p> <p><strong>出于性能考虑，React 可能会把多个 setState() 调用合并成⼀个调用</strong></p> <p>批量操作：对同一个 key 多次操作会合并，会执行最后一次</p> <div class="language- extra-class"><pre><code>changeValue = v =&gt; {
    this.setState({
        counter: this.state.counter + v
    });
};
setCounter = () =&gt; {
    this.changeValue(1);
    this.changeValue(2);
};

如果想要链式更更新state:

changeValue = v =&gt; {
    this.setState(state =&gt; ({ counter: state.counter + v }));
};
setCounter = () =&gt; {
    this.changeValue(1);
    this.changeValue(2);
};
</code></pre></div><p>3.State 的更新可能是异步的</p> <div class="language- extra-class"><pre><code>class Clock extends Component {

state = { date: new Date(), counter: 1 };

componentDidMount() {
    this.timer = setInterval(() =&gt; {
    //   setState修改状态
    this.setState({ date: new Date() });
    }, 1000);

    // 批量操作：对同一个key多次操作会合并，会执行最后一次
    this.setState({ counter: this.state.counter + 1 });
    this.setState({ counter: this.state.counter + 1 });
    this.setState({ counter: this.state.counter + 1 }, ()=&gt;{
        console.log('cb'+this.state.counter); // 2 在回调中获取状态值
    });
    console.log(this.state.counter); // 1

    this.setState(prev =&gt; {
    console.log(prev.counter); // 2
    return prev.counter;
    });

    setTimeout(() =&gt; {
        console.log(this.state.counter); // 2 使⽤用定时器器:
    }, 0);

    document.body.addEventListener(&quot;click&quot;, this.changeCounter); //原⽣生事件中修改状态
}

changeCounter = () =&gt; {
    this.setState({ counter: this.state.counter + 1 });
    console.log(this.state.counter); // 3
};

componentWillUnmount() {
    clearInterval(this.timer);
}

render() {
    return (
    &lt;div&gt;
        {this.state.date.toLocaleTimeString()}
        &lt;p&gt;{this.state.counter}&lt;/p&gt;
    &lt;/div&gt;
    );
}
}
</code></pre></div><p>如果要获取到最新状态值有以下⽅方式:</p> <ol><li>在回调中获取状态值</li> <li>使⽤用定时器器:</li> <li>原⽣事件中修改状态</li></ol> <p>setState 只有在合成事件和⽣命周期函数中是异步的，react 基本都是合成事件<br>
在原⽣事件和 setTimeout 中都是同步 的，这⾥的异步其实是批量更新。</p> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <h3 id="react-v16-3-之前的生命周期"><a href="#react-v16-3-之前的生命周期" class="header-anchor">#</a> React V16.3 之前的生命周期</h3> <p><img src="/assets/img/3.0081fb45.png" alt="1"></p> <h3 id="react-v16-4-之后的生命周期"><a href="#react-v16-4-之后的生命周期" class="header-anchor">#</a> React V16.4 之后的生命周期</h3> <p><img src="/assets/img/2.2a48f305.png" alt="2"></p> <p>引入两个新的生命周期
static getDerivedStateFromProps <br>
getSnapshotBeforeUpdate</p> <h4 id="挂载"><a href="#挂载" class="header-anchor">#</a> 挂载</h4> <p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p> <div class="language- extra-class"><pre><code>1.constructor()
2.static getDerivedStateFromProps()
3.render()
4.componentDidMount()
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>下述生命周期方法即将过时，在新代码中应该避免使用它们：
UNSAFE_componentWillMount()</p></div> <h4 id="更新"><a href="#更新" class="header-anchor">#</a> 更新</h4> <p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p> <div class="language- extra-class"><pre><code>1.static getDerivedStateFromProps()
2.shouldComponentUpdate()
3.render()
4.getSnapshotBeforeUpdate()
5.componentDidUpdate()
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>下述方法即将过时，在新代码中应该避免使用它们：<br>
UNSAFE_componentWillUpdate()<br>
UNSAFE_componentWillReceiveProps()</p></div> <h4 id="卸载"><a href="#卸载" class="header-anchor">#</a> 卸载</h4> <p>当组件从 DOM 中移除时会调用如下方法：</p> <div class="language- extra-class"><pre><code>componentWillUnmount()
</code></pre></div><h4 id="错误处理"><a href="#错误处理" class="header-anchor">#</a> 错误处理</h4> <p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p> <div class="language- extra-class"><pre><code>static getDerivedStateFromError()
componentDidCatch()
</code></pre></div><h3 id="render"><a href="#render" class="header-anchor">#</a> render()</h3> <p>class 组件中唯一必须实现的方法。<br>
render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，<br>
每次调用时都返回相同的结果，并且它不会直接与浏览器交互。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>如果 shouldComponentUpdate() 返回 false，则不会调用 render()</p></div> <h3 id="constructor"><a href="#constructor" class="header-anchor">#</a> constructor()</h3> <p>在 React 组件挂载之前，会调用它的构造函数。<br>
在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 super(props)。<br>
否则，this.props 在构造函数中可能会出现未定义的 bug<br></p> <p>通常，在 React 中，构造函数仅用于以下两种情况：<br></p> <p>1.通过给 this.state 赋值对象来初始化内部 state。<br> 2.为事件处理函数绑定实例</p> <div class="language- extra-class"><pre><code>constructor(props) {
super(props);
// 不要在这里调用 this.setState()
this.state = { counter: 0 };
this.handleClick = this.handleClick.bind(this);
}
</code></pre></div><h3 id="componentdidmount"><a href="#componentdidmount" class="header-anchor">#</a> componentDidMount()</h3> <p>componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p> <p>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅</p> <p>你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理</p> <h3 id="componentdidupdate"><a href="#componentdidupdate" class="header-anchor">#</a> componentDidUpdate()</h3> <div class="language- extra-class"><pre><code>componentDidUpdate(prevProps, prevState, snapshot)
</code></pre></div><p>componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法</p> <p>当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。</p> <div class="language- extra-class"><pre><code>componentDidUpdate(prevProps) {
// 典型用法（不要忘记比较 props）：
    if (this.props.userID !== prevProps.userID) {
        this.fetchData(this.props.userID);
    }
}
</code></pre></div><p>如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。</p> <h3 id="componentwillunmount"><a href="#componentwillunmount" class="header-anchor">#</a> componentWillUnmount()</h3> <p>componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。</p> <h3 id="shouldcomponentupdate"><a href="#shouldcomponentupdate" class="header-anchor">#</a> shouldComponentUpdate()</h3> <div class="language- extra-class"><pre><code>shouldComponentUpdate(nextProps, nextState)
</code></pre></div><p>根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。<br>
默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。<br></p> <p>当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。<br>
返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。</p> <p><code>此方法仅作为性能优化的方式而存在。</code>不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p> <p>如果你一定要手动编写此函数，可以将 this.props 与 nextProps 以及 this.state 与 nextState 进行比较，并返回 false 以告知 React 可以跳过更新。请注意，返回 false 并不会阻止子组件在 state 更改时重新渲染。</p> <p>我们不建议在 shouldComponentUpdate() 中进行深层比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能</p> <h3 id="static-getderivedstatefromprops"><a href="#static-getderivedstatefromprops" class="header-anchor">#</a> static getDerivedStateFromProps()</h3> <div class="language- extra-class"><pre><code>static getDerivedStateFromProps(props, state)
</code></pre></div><p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p> <h3 id="getsnapshotbeforeupdate"><a href="#getsnapshotbeforeupdate" class="header-anchor">#</a> getSnapshotBeforeUpdate()</h3> <div class="language- extra-class"><pre><code>getSnapshotBeforeUpdate(prevProps, prevState)
</code></pre></div><p>getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。</p> <p>此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p> <p>应返回 snapshot 的值（或 null）。</p> <h3 id="static-getderivedstatefromerror"><a href="#static-getderivedstatefromerror" class="header-anchor">#</a> static getDerivedStateFromError()</h3> <p>此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state
当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI</p> <h3 id="componentdidcatch"><a href="#componentdidcatch" class="header-anchor">#</a> componentDidCatch()</h3> <div class="language- extra-class"><pre><code>componentDidCatch(error, info)
</code></pre></div><p>此生命周期在后代组件抛出错误后被调用。 它接收两个参数：</p> <p>使用 componentDidCatch() 打印错误信息。
error —— 抛出的错误。
info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。
componentDidCatch() 会在“提交”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况：</p> <h2 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h2> <p>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</p> <p>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</p> <div class="language- extra-class"><pre><code>class LoggingButton extends React.Component {
    constructor(props) {
        super(props);
        this.state = {isToggleOn: true};

        // 为了在回调中使用 `this`，这个绑定是必不可少的
        this.handleClick = this.handleClick.bind(this);
    }
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    // 注意: 这是 *实验性* 语法。
    handleClick = () =&gt; {
        console.log('this is:', this);
    }
    handleClick() {
        console.log('this is:', this);
    }

    render() {
        // 此语法确保 `handleClick` 内的 `this` 已被绑定。
        return (
        &lt;button onClick={() =&gt; this.handleClick()}&gt;
            Click me
        &lt;/button&gt;
        //React 的事件对象 e 会被作为第二个参数传递。在这里，e 是一个合成事件。如果通过箭头函数的方式，
        事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。
        &lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
        &lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;
        );
    }
}
</code></pre></div><h2 id="条件渲染-列表-key"><a href="#条件渲染-列表-key" class="header-anchor">#</a> 条件渲染 列表 &amp; Key</h2> <p>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题</p> <h2 id="表单"><a href="#表单" class="header-anchor">#</a> 表单</h2> <div class="language- extra-class"><pre><code>&lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt; 和 &lt;select&gt; 之类的标签都
非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件
&lt;input type=&quot;file&quot; /&gt; 它的 value 只读，所以它是 React 中的一个非受控组件

处理多个输入
当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，
并让处理函数根据 event.target.name 的值选择要执行的操作
handleInputChange(event) {
    const target = event.target;
    const value = target.type === 'checkbox' ? target.checked : target.value;
    const name = target.name;

    this.setState({
    [name]: value
    });
}
</code></pre></div><h2 id="组件-组件复合"><a href="#组件-组件复合" class="header-anchor">#</a> 组件 组件复合</h2> <p>组件有两种形式:class 组件和 function 组件。 组件命名首字母大写 MyComponent</p> <h3 id="class-组件"><a href="#class-组件" class="header-anchor">#</a> class 组件</h3> <p>class 组件通常拥有状态和⽣命周期，继承于 Component，实现 render ⽅法</p> <div class="language- extra-class"><pre><code>class Abc extends React.Component{

    render() {
        return &lt;div&gt;{this.state.date.toLocaleTimeString()}&lt;/div&gt;;
    }

}
</code></pre></div><h3 id="function-组件"><a href="#function-组件" class="header-anchor">#</a> function 组件</h3> <p>函数组件通常无状态，仅关注内容展示，返回渲染结果即可。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>从 React16.8 开始引⼊入了了 hooks，函数组件也能够拥有状态</p></div> <div class="language- extra-class"><pre><code>import React, { useState, useEffect } from &quot;react&quot;;
export function FunctionComponent(props) {

    const [date, setDate] = useState(new Date());

    useEffect(() =&gt; {//副作⽤用
        const timer = setInterval(() =&gt; {
            setDate(new Date());
        }, 1000);
        return () =&gt; clearInterval(timer);//组件卸载的时候执⾏
    }, []);

return (
    &lt;div&gt;
    &lt;h3&gt;FunctionComponent&lt;/h3&gt;
    &lt;p&gt;{date.toLocaleTimeString()}&lt;/p&gt;
    &lt;/div&gt;
); }
</code></pre></div><h3 id="复合"><a href="#复合" class="header-anchor">#</a> 复合</h3> <p>不具名</p> <div class="language- extra-class"><pre><code>import React, { Component } from &quot;react&quot;;
import TopBar from &quot;../components/TopBar&quot;;
import BottomBar from &quot;../components/BottomBar&quot;;

export default class Layout extends Component {
    componentDidMount() {
        const { title = &quot;商城&quot; } = this.props;
        document.title = title;
    }
     render() {
        const { children, showTopBar, showBottomBar } = this.props;
        console.log(&quot;children&quot;, children);
        return (
        &lt;div&gt;
            {showTopBar &amp;&amp; &lt;TopBar /&gt;}
            {children.content}
            {children.txt}
            &lt;button onClick={children.btnClick}&gt;button&lt;/button&gt;
            {showBottomBar &amp;&amp; &lt;BottomBar /&gt;}
        &lt;/div&gt;
    ); }
}

import React, { Component } from &quot;react&quot;;
import Layout from &quot;./Layout&quot;;

export default class UserPage extends Component {
render() {
    return (
    &lt;Layout showTopBar={true} showBottomBar={true} title=&quot;⽤用户中⼼心&quot;&gt;
            &lt;div&gt;
            &lt;h3&gt;UserPage&lt;/h3&gt;
            &lt;/div&gt;
        &lt;/Layout&gt;
    ); }
}
</code></pre></div><p>具名</p> <div class="language- extra-class"><pre><code>import React, { Component } from 'react'

function Formbutton(props) {
    return &lt;div className=&quot;Formbutton&quot;&gt;
        &lt;button onClick={props.children.defaultBtns.searchClick}&gt;默认查询&lt;/button&gt; &lt;button onClick={props.children.defaultBtns.resetClick}&gt;默认重置&lt;/button&gt;
    {
        props.children.btns.map((item, index) =&gt; {
            return &lt;button key={'btn' + index} onClick={item.onClick}&gt;{item.title}&lt;/button&gt;
        })

    }
    &lt;/div&gt;
}


&lt;Formbutton&gt;
    {
        {
            defaultBtns:{
                searchClick: () =&gt; console.log('默认查询'),
                resetClick: () =&gt; console.log('默认重置')
            }
        }
    }
&lt;/Formbutton&gt;

React.Children.map(props.children, child=&gt;child.type==='p')
类似的还有React.Children.forEach，React.Children.toArray等
</code></pre></div><h2 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h2> <p>高阶组件 HOC(Higher-Order Components)是 React 中重用组件逻辑的高级技术， <br>
它不是 react 的 api，而是一种 组件增强模式。高阶组件是一个函数，它返回另外一个组件，<br>
产生新的组件可以对被包装组件属性进行包装，也可 以重写部分生命周期</p> <div class="language- extra-class"><pre><code>const withKaikeba = (Component) =&gt; {
    const NewComponent = (props) =&gt; {
    return &lt;Component {...props} name=&quot;高阶组件&quot; /&gt;; };
    return NewComponent;
};
</code></pre></div><h3 id="链式调用"><a href="#链式调用" class="header-anchor">#</a> 链式调用</h3> <div class="language- extra-class"><pre><code>const withLog = Component=&gt;{
class NewComponent extends React.Component{
    render(){
        return &lt;Component {...this.props} /&gt;;
    }
    componentDidMount(){
        console.log('didMount',this.props)
    }
}
return NewComponent
}
class App extends Component {
    render() {
        return (
        &lt;div className=&quot;App&quot;&gt;
        &lt;h2&gt;hi,{this.props.name}&lt;/h2&gt;
            &lt;Button type=&quot;primary&quot;&gt;Button&lt;/Button&gt;
        &lt;/div&gt;
    ) }
    }
export default withKaikeba(withLog(App))
</code></pre></div><h3 id="装饰器"><a href="#装饰器" class="header-anchor">#</a> 装饰器</h3> <p>ES7 中有一个优秀的语法—装饰器 ，可使代码更简洁</p> <p>npm install -D @babel/plugin-proposal-decorators</p> <div class="language- extra-class"><pre><code>const { addDecoratorsLegacy } = require(&quot;customize-cra&quot;);
module.exports = override(
    ...,
    addDecoratorsLegacy()
);

// 应用
const withLog = Component=&gt;{...}
const withKaikeba = Component=&gt;{...}
@withKaikeba
@withLog
class App extends Component {
render() {
    return (
    &lt;div className=&quot;App&quot;&gt;
    &lt;h2&gt;hi,{this.props.name}&lt;/h2&gt;
        &lt;Button type=&quot;primary&quot;&gt;Button&lt;/Button&gt;
    &lt;/div&gt;
) }
}
export default App
</code></pre></div><h2 id="react-createelement-与-react-cloneelement"><a href="#react-createelement-与-react-cloneelement" class="header-anchor">#</a> React.createElement() 与 React.cloneElement()</h2> <p>React.createElement()： 根据指定的第一个参数创建一个 React 元素。
第三个参数可以分开也可以写成一个数组</p> <div class="language- extra-class"><pre><code>React.createElelment(type,[props],[...children])
第一个参数是必填，传入的是似HTML标签名称，eg: ul, li
第二个参数是选填，表示的是属性，eg: className
第三个参数是选填, 子节点，eg: 要显示的文本内容

var child1 = React.createElement('li', null, 'one');
var child2 = React.createElement('li', null, 'two');
React.createElement('ul', { className: 'teststyle' }, child1, child2)
React.createElement('ul', { className: 'teststyle' }, [child1, child2])
</code></pre></div><p>React.cloneElement() 克隆并返回一个新的 ReactElement （内部子元素也会跟着克隆），<br>
新返回的元素会保留有旧元素的 props、ref、key，也会集成新的 props（只要在第二个参数中有定义）。</p> <div class="language- extra-class"><pre><code>React.cloneElement(element,[props],[...children])

renderChildren() {
    return React.Children.map(this.props.children, child =&gt; {
        return React.cloneElement(child, {
            name: this.props.name
        })
    })
}
</code></pre></div><h2 id="purecomponent"><a href="#purecomponent" class="header-anchor">#</a> PureComponent</h2> <p>定制了 shouldComponentUpdate 后的 Component,<code>必须要用class形式，⽽且要注意是浅⽐较</code></p> <div class="language- extra-class"><pre><code>React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层⽐较,浅层对⽐ prop 和 state 。
如果对象中 包含复杂的数据结构，则有可能因为⽆法检查深层的差别，产⽣生错误的⽐对结果。
仅在你的 props 和 state 较为简单时，才使⽤用 React.PureComponent ，
或者在深层数据结构发生变化时 调⽤用 forceUpdate() 来确保组件被正确地更新。
你也可以考虑使⽤ immutable 对象加速嵌套数据的比较。
此外， React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop
更新。因此，请确保所有⼦组件也都是“纯”的组件
</code></pre></div><h2 id="react-memo"><a href="#react-memo" class="header-anchor">#</a> React.memo</h2> <div class="language- extra-class"><pre><code>React 16.6.0 使用 React.memo 让函数式的组件也有PureComponent的功能
const Joke = React.memo(() =&gt; (
    &lt;div&gt;
        {this.props.value || 'loading...' }
    &lt;/div&gt;
));
</code></pre></div><h2 id="fragments"><a href="#fragments" class="header-anchor">#</a> Fragments</h2> <p>Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点 简写&lt;&gt;&lt;/&gt;</p> <h2 id="context-组件跨层级通信"><a href="#context-组件跨层级通信" class="header-anchor">#</a> Context 组件跨层级通信</h2> <p>vuejs 的 privide&amp;inject 模式的来源---context
这种模式下有两个角色:
-Provider:外层提供数据的组件
-Consumer :内层获取数据的组件</p> <div class="language- extra-class"><pre><code>const FormContext = React.createContext()
const FormProvider = FormContext.Provider
const FormConsumer = FormContext.Consumer
const store ={ name:'erdang'}
class ContextTest extends Component {
    render() {
        return &lt;FormProvider value={store}&gt;
        &lt;FormConsumer&gt;
            {store=&gt;&lt;p&gt;{store.name}&lt;/p&gt;}
        &lt;/FormConsumer&gt;
        &lt;/FormProvider&gt;
    }
}
</code></pre></div><h2 id="refs-and-the-dom"><a href="#refs-and-the-dom" class="header-anchor">#</a> Refs and the DOM</h2> <p>何时使用 Refs</p> <ul><li>管理焦点，文本选择或媒体播放。</li> <li>触发强制动画。</li> <li>集成第三方 DOM 库。</li></ul> <p>Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素</p> <div class="language- extra-class"><pre><code>class MyComponent extends React.Component {
    constructor(props) {
        super(props);
        this.myRef = React.createRef();
    }
    render() {
        return &lt;div ref={this.myRef} /&gt;;
    }
}

const node = this.myRef.current;
//挂载到dom 上就是dom元素   挂载的组件 就是组件实例
</code></pre></div><p>函数组件 ref</p> <div class="language- extra-class"><pre><code>function CustomTextInput(props) {
// 这里必须声明 textInput，这样 ref 才可以引用它
const textInput = useRef(null);

function handleClick() {
    textInput.current.focus();
}

return (
    &lt;div&gt;
    &lt;input
        type=&quot;text&quot;
        ref={textInput} /&gt;
    &lt;input
        type=&quot;button&quot;
        value=&quot;Focus the text input&quot;
        onClick={handleClick}
    /&gt;
    &lt;/div&gt;
)
</code></pre></div><p>回调 ref</p> <div class="language- extra-class"><pre><code>class CustomTextInput extends React.Component {
    constructor(props) {
        super(props);
        this.textInput = null;
        this.setTextInputRef = element =&gt; {
            this.textInput = element;
        };

        this.focusTextInput = () =&gt; {
            // 使用原生 DOM API 使 text 输入框获得焦点
            if (this.textInput) this.textInput.focus();
        };
    }

    componentDidMount() {
        // 组件挂载后，让文本框自动获得焦点
        this.focusTextInput();
    }

    render() {
        // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React
        // 实例上（比如 this.textInput）
        return (
        &lt;div&gt;
            &lt;input
            type=&quot;text&quot;
            ref={this.setTextInputRef}
            /&gt;
            &lt;input
            type=&quot;button&quot;
            value=&quot;Focus the text input&quot;
            onClick={this.focusTextInput}
            /&gt;
        &lt;/div&gt;
        );
    }
}
</code></pre></div><h3 id="react-forwardref"><a href="#react-forwardref" class="header-anchor">#</a> React.forwardRef</h3> <p>你可能希望在父组件中引用子节点的 DOM 节点 转发</p> <p>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧</p> <div class="language- extra-class"><pre><code>const FancyButton = React.forwardRef((props, ref) =&gt; (
&lt;button ref={ref} className=&quot;FancyButton&quot;&gt;
    {props.children}
&lt;/button&gt;
));

// 你可以直接获取 DOM button 的 ref：
const ref = React.createRef();
&lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;;

1.我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。
2.我们通过指定 ref 为 JSX 属性，将其向下传递给 &lt;FancyButton ref={ref}&gt;。
3.React 传递 ref 给 forwardRef 内函数 (props, ref) =&gt; ...，作为其第二个参数。
4.我们向下转发该 ref 参数到 &lt;button ref={ref}&gt;，将其指定为 JSX 属性。
5.当 ref 挂载完成，ref.current 将指向 &lt;button&gt; DOM 节点。
</code></pre></div><p>在高阶组件中转发 refs <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener noreferrer">高阶组件转发<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="portals"><a href="#portals" class="header-anchor">#</a> Portals</h2> <p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p> <div class="language- extra-class"><pre><code>ReactDOM.createPortal(child, container)
第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。
第二个参数（container）是一个 DOM 元素。
</code></pre></div><h2 id="render-props"><a href="#render-props" class="header-anchor">#</a> Render Props</h2> <p>一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p> <p>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑</p> <div class="language- extra-class"><pre><code>&lt;DataProvider render={data =&gt; (
    &lt;h1&gt;Hello {data.target}&lt;/h1&gt;
)}/&gt;
</code></pre></div><h2 id="strictmode"><a href="#strictmode" class="header-anchor">#</a> StrictMode</h2> <p>StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。</p> <p>它为其后代元素触发额外的检查和警告。</p> <h2 id="proptypes"><a href="#proptypes" class="header-anchor">#</a> PropTypes</h2> <div class="language- extra-class"><pre><code>import PropTypes from 'prop-types'

function HelloWorldComponent({ name }) {
return (
    &lt;div&gt;Hello, {name}&lt;/div&gt;
)
}

HelloWorldComponent.propTypes = {
name: PropTypes.string
}

export default HelloWorldComponent
</code></pre></div></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/04/24, 18:51:09</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/da5329/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">hook</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/da5329/">hook</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:924064382@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/erdang" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2021-2023
    <span>Er Dang | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><i class="close-but">×</i> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;width:160px;height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c3eaab60.js" defer></script><script src="/assets/js/2.0d541d74.js" defer></script><script src="/assets/js/5.20cfe6af.js" defer></script>
  </body>
</html>
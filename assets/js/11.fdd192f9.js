(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{442:function(e,a,s){"use strict";s.r(a);var r=s(23),l=Object(r.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"babel"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#babel"}},[e._v("#")]),e._v(" Babel")]),e._v(" "),s("p",[s("code",[e._v("Babel")]),e._v(" 是一个工具链，主要用于将采用 "),s("code",[e._v("ECMAScript 2015+")]),e._v(" 语法编写的代码转换为向后兼容的 "),s("code",[e._v("JavaScript 语法")]),e._v("，以便能够运行在当前和旧版本的浏览器或其他环境中。")]),e._v(" "),s("p",[e._v("我们一般用 Babel 做下面几件事：")]),e._v(" "),s("ul",[s("li",[e._v("语法转换（"),s("code",[e._v("es-higher")]),e._v(" -> "),s("code",[e._v("es-lower")]),e._v("）;")]),e._v(" "),s("li",[e._v("通过 "),s("code",[e._v("Polyfill")]),e._v(" 处理在目标环境无法转换的特性（通过 "),s("code",[e._v("core-js")]),e._v(" 实现）;")]),e._v(" "),s("li",[e._v("源码转换（"),s("code",[e._v("codemods")]),e._v("、"),s("code",[e._v("jscodeshift")]),e._v("）;")]),e._v(" "),s("li",[e._v("静态分析（"),s("code",[e._v("lint")]),e._v("、根据注释生成 "),s("code",[e._v("API")]),e._v(" 文档等）;")])]),e._v(" "),s("h2",{attrs:{id:"关于-babel-版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于-babel-版本"}},[e._v("#")]),e._v(" 关于 Babel 版本")]),e._v(" "),s("p",[e._v("目前，前端开发领域使用的 Babel 版本主要的 Babel6 和 Babel7 这两个版本。")]),e._v(" "),s("p",[e._v("Babel 是一个工具集，而这个工具集是围绕@babel/core 这个核心 npm 包构成的。每次@babel/core 发布新版本的时候，整个工具集的其它 npm 包也都会跟着升级到与@babel/core 相同的版本号，即使它们的代码可能一行都没有改变。")]),e._v(" "),s("p",[e._v("Babel7 的 npm 包都是放在 babel 域下的，即在安装 npm 包的时候，我们是安装@babel/这种方式，例如@babel/cli、@babel/core 等。而在 Babel6，我们安装的包名是 babel-cli，babel-core 等。其实它们本质是一样的，都是 Babel 官方的 cli 命令行工具和 core 核心包，而且功能是一样的，只是名称版本变化了一下而已。在平时开发和学习的过程中，碰到'@babel/'和'babel-'应该下意识认识到他俩原本是一个包，只是版本不一样而已。")]),e._v(" "),s("h2",{attrs:{id:"babel-配置文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#babel-配置文件"}},[e._v("#")]),e._v(" Babel 配置文件")]),e._v(" "),s("p",[e._v("Babel 的配置文件是 Babel 执行时默认会在当前目录寻找的文件，主要有.babelrc，.babelrc.js，babel.config.js 和 package.json。它们的配置项都是相同，作用也是一样的，只需要选择其中一种。")]),e._v(" "),s("p",[e._v("对于.babelrc，它的配置是这样子")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('{\n    "presets": ["es2015", "react"],\n    "plugins": ["transform-decorators-legacy", "transform-class-properties"]\n}\n')])])]),s("p",[e._v("对于 babel.config.js 和.babelrc.js，它的配置是一样的，通过 module.exports 输出配置项")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('module.exports = {\n    "presets": ["es2015", "react"],\n    "plugins": ["transform-decorators-legacy", "transform-class-properties"]\n}\n')])])]),s("p",[e._v("对于 package.json，就是在 package.json 中增加一个 babel 属性和值，它的配置是这样子")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('{\n    "name": "demo",\n    "version": "1.0.0",\n    "description": "",\n    "main": "index.js",\n    "scripts": {\n        "test": "echo \\"Error: no test specified\\" && exit 1"\n    },\n    "author": "",\n    "babel": {\n        "presets": ["es2015", "react"],\n        "plugins": ["transform-decorators-legacy", "transform-class-properties"]\n    }\n}\n')])])]),s("p",[e._v("在 webpack 配置文件中，我们把 babel-loader 添加到 module 的 loaders 列表中：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("module: {\n    rules: [\n    {\n        test: /\\.js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n        loader: 'babel-loader',\n        options: {\n            presets: ['@babel/preset-env']\n        }\n        }\n    }\n    ]\n}\n")])])]),s("p",[e._v("在这里，我们通过 options 属性给 babel-loader 传递预设和插件等 Babel 配置项。我们也可以省略这个 options，这个时候 babel-loader 会去读取默认的 Babel 配置文件，也就是.babelrc，.babelrc.js，babel.config.js 等。在现在的前端开发中，建议通过配置文件来传递这些配置项。")]),e._v(" "),s("h2",{attrs:{id:"插件与预设"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插件与预设"}},[e._v("#")]),e._v(" 插件与预设")]),e._v(" "),s("p",[e._v("plugin 代表插件，preset 代表预设，它们分别放在 plugins 和 presets，每个插件或预设都是一个 npm 包。")]),e._v(" "),s("p",[e._v("plugins 插件数组和 presets 预设数组是有顺序要求的。如果两个插件或预设都要处理同一个代码片段，那么会根据插件和预设的顺序来执行。规则如下")]),e._v(" "),s("ul",[s("li",[e._v("插件比预设先执行")]),e._v(" "),s("li",[e._v("插件执行顺序是插件数组从前向后执行")]),e._v(" "),s("li",[e._v("预设执行顺序是预设数组从后向前执行")])]),e._v(" "),s("h3",{attrs:{id:"preset-预设的选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#preset-预设的选择"}},[e._v("#")]),e._v(" preset 预设的选择")]),e._v(" "),s("p",[e._v("在 Babel6 的时代 ,很复杂,一言难尽 ,现在只需一个"),s("code",[e._v("@babel/preset-env")]),e._v("就可以了")]),e._v(" "),s("p",[e._v("在实际开发过程中，除了使用@babel/preset-env 对标准的 ES6 语法转换，我们可能还需要类型检查和 react 等预设对特定语法转换。这里有三个官方预设可以使用：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("* @babel/preset-flow\n* @babel/preset-react\n* @babel/preset-typescript\n")])])]),s("p",[e._v("总结起来，Babel 官方的 preset，我们实际可能会用到的其实就只有 4 个：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("* @babel/preset-env\n* @babel/preset-flow\n* @babel/preset-react\n* @babel/preset-typescript\n")])])]),s("p",[e._v('一个普通的 vue 工程，Babel 官方的 preset 只需要配一个"@babel/preset-env"就可以了')]),e._v(" "),s("h4",{attrs:{id:"babel-preset-env"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#babel-preset-env"}},[e._v("#")]),e._v(" @babel/preset-env")]),e._v(" "),s("p",[e._v("在 Babel6 时代，这个预设名字是 babel-preset-env，在 Babel7 之后，改成@babel/preset-env。除了进行语法转换，该预设还可以通过设置参数项进行针对性语法转换以及 polyfill 的按需引入")]),e._v(" "),s("p",[e._v("在使用它之前，需要先安装")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v(" npm install --save-dev @babel/core @babel/cli @babel/preset-env\n")])])]),s("p",[e._v("以 babel.config.js 为例,对于 preset，当我们不需要对其设置参数的时候")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('module.exports = {\n    presets: ["@babel/preset-env"],\n    plugins: []\n}\n')])])]),s("p",[s("strong",[e._v("targets")]),e._v(" 该参数项可以取值为字符串、字符串数组或对象，默认{},targets > browserslist(都没设置 全部 es6=>es5)")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('module.exports = {\n    presets: [["@babel/env", {\n    targets: {\n        "chrome": "58",\n        "ie": "11"\n    },\n    "useBuiltIns": "usage",\n    "corejs": 3\n    }]],\n    plugins: []\n}\n')])])]),s("p",[s("strong",[e._v("useBuiltIns")]),e._v(" 默认值 false")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('    usage：每个文件引用使用到的特性；\n    false：不引入,如果 引入 @babel/polyfill 则全引入\n    entry：全部引入,需要 入口文件\n           import "core-js/stable";\n           import "regenerator-runtime/runtime";\n')])])]),s("p",[s("strong",[e._v("corejs")]),e._v(" 默认值 2,只有 useBuiltIns 设置为'usage'或'entry'时，才会生效\n2 对应 core-js@2 ,3 对应 core-js@3(目前多用的是 3)")]),e._v(" "),s("p",[e._v("ps:Browserslist 叫做目标环境配置表，除了写在 package.json 里，也可以单独写在工程目录下.browserslistrc 文件里。我们用 browserslist 来指定代码最终要运行在哪些浏览器或 node.js 环境。Autoprefixer、postcss 等就可以根据我们的 browserslist，来自动判断是否要增加 CSS 前缀（例如'-webkit-'）。我们的 Babel 也可以使用 browserslist，如果你使用了@babel/preset-env 这个预设，此时 Babel 就会读取 browserslist 的配置。")]),e._v(" "),s("p",[e._v("如果我们的@babel/preset-env 不设置任何参数，Babel 就会完全根据 browserslist 的配置来做语法转换。如果没有 browserslist，那么 Babel 就会把所有 ES6 的语法转换成 ES5 版本。")]),e._v(" "),s("h4",{attrs:{id:"babel6-到-babel7-的升级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#babel6-到-babel7-的升级"}},[e._v("#")]),e._v(" Babel6 到 Babel7 的升级")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("废弃了 stage-x 和 es20xx 的 preset，改成 preset-env 和 plugin-proposal-xx；这样能更好地控制需要支持的特性；")])]),e._v(" "),s("li",[s("p",[s("code",[e._v("preset-env")]),e._v(" 依赖 "),s("code",[e._v("browserslist")]),e._v(", "),s("code",[e._v("compat-table")]),e._v(", and "),s("code",[e._v("electron-to-chromium")]),e._v(" 实现了特性的精细按需引入。")])])]),e._v(" "),s("h5",{attrs:{id:"compat-table-这个库维护着每个特性在不同环境的支持情况"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compat-table-这个库维护着每个特性在不同环境的支持情况"}},[e._v("#")]),e._v(" compat-table  这个库维护着每个特性在不同环境的支持情况")]),e._v(" "),s("h3",{attrs:{id:"plugin-插件的选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#plugin-插件的选择"}},[e._v("#")]),e._v(" plugin 插件的选择")]),e._v(" "),s("p",[e._v("虽然 Babel7 官方有 90 多个插件，不过大半已经整合在@babel/preset-env 和@babel/preset-react 等预设里了，我们在开发的时候直接使用预设就可以了。")]),e._v(" "),s("p",[e._v("目前比较常用的插件只有@babel/plugin-transform-runtime。")]),e._v(" "),s("p",[e._v("1.自动移除语法转换后内联的辅助函数")]),e._v(" "),s("p",[e._v("2.当代码里使用了 core-js 的 API，自动引入@babel/runtime-corejs3/core-js-stable/，以此来替代全局引入的 core-js/stable;")]),e._v(" "),s("p",[e._v("3.当代码里使用了 Generator/async 函数，自动引入@babel/runtime/regenerator，以此来替代全局引入的 regenerator-runtime/runtime")]),e._v(" "),s("p",[s("code",[e._v("作用2和3其实是在做API转换，对内置对象进行重命名，以防止污染全局环境。")])]),e._v(" "),s("p",[e._v("引入'babel-polyfill'或'core-js/stable 与 regenerator-runtime/runtime'来做全局的 API 补齐。但这样可能有一个问题，那就是对运行环境产生了污染。例如 Promise，我们的 polyfill 是"),s("code",[e._v("对浏览器的全局对象进行了重新赋值，我们重写了Promise及其原型链")]),e._v(",会对浏览器环境产生污染（即修改了浏览器的 window.Promise）。")]),e._v(" "),s("p",[e._v("例子")]),e._v(" "),s("p",[e._v("Babel 转换前的代码")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("var obj = Promise.resolve();\n")])])]),s("p",[e._v("若使用了'babel-polyfill'或'core-js/stable 与 regenerator-runtime/runtime'来做全局的 API 补齐，那么 Babel 转换后的代码仍然是")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("var obj = Promise.resolve();\n")])])]),s("p",[e._v("polyfill 只是补齐了浏览器的 window.Promise 对象。")]),e._v(" "),s("p",[e._v("若我们不使用 polyfill，而开启@babel/plugin-transform-runtime 的 API 转换功能。那么 Babel 转换后的代码将是")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");\nvar _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));\nvar obj = _promise["default"].resolve();\n')])])]),s("p",[e._v('@babel/plugin-transform-runtime 把我们代码里的 Promise 变成了_promise["default"]，而_promise["default"]拥有 ES 标准里 Promise 所有的功能。现在，即使浏览器没有 Promise，我们的代码也能正常运行。')]),e._v(" "),s("p",[s("code",[e._v("API转换有什么用，明明通过polyfill补齐API的方式也可以使代码在浏览器正常运行？")])]),e._v(" "),s("p",[e._v("API 转换主要是给开发 JS 库或 npm 包等的人用的，我们的前端工程一般仍然使用 polyfill 补齐 API。")]),e._v(" "),s("p",[s("code",[e._v("@babel/runtime包提供辅助函数模块,他的的进化版@babel/runtime-corejs3")])]),e._v(" "),s("p",[e._v("如果我们使用@babel/plugin-transform-runtime 来做 polyfill 的事情，那么就不要再使用之前讲过的 polyfill 方式了，无论是单独引入还是@babel/preset-env 的方式。因为我们用 transform-runtime 来做 api 转换的目的是不污染全局作用域。")]),e._v(" "),s("p",[e._v("默认值")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('{\n    "plugins": [\n        [\n            "@babel/plugin-transform-runtime",\n            {\n                "helpers": true, 否要自动引入辅助函数包\n                "corejs": false, corejs取值是false、2和3 开发JS库的时候设为2和3\n                "regenerator": true, corejs和regenerator 两项 是否做API转换以避免污染全局环境\n                "useESModules": false, 是否使用ES6的模块化用法,在用webpack一类的打包工具的时候，可以设置为true，以便做静态分析\n                "absoluteRuntime": false,\n                "version": "7.0.0-beta.0"\n            }\n        ]\n    ]\n}\n')])])]),s("p",[e._v("PS:每个转换后的文件上部都会注入这些相同的函数声明，那为何不用 webpack 一类的打包工具去掉重复的函数声明，而是要单独再引一个辅助函数包？")]),e._v(" "),s("p",[e._v("webpack 在构建的时候，是基于模块来做去重工作的。每一个函数声明都是引用类型，在堆内存不同的空间存放，缺少唯一的地址来找到他们。所以 webpack 本身是做不到把每个文件的相同函数声明去重的。因此我们需要单独的辅助函数包，这样 webpack 打包的时候会基于模块来做去重工作。")]),e._v(" "),s("h4",{attrs:{id:"babel-共有3种插件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#babel-共有3种插件"}},[e._v("#")]),e._v(" babel 共有3种插件：")]),e._v(" "),s("p",[e._v("1."),s("code",[e._v("babel-plugin-transform-xx")]),e._v("：转换插件，主要用来加强转换能力；")]),e._v(" "),s("p",[e._v("2."),s("code",[e._v("babel-plugin-syntax-xx")]),e._v("：语法插件，主要是扩展编译能力，比如不在 async 函数作用域里面使用 await，如果不引入"),s("code",[e._v("@babel/plugin-syntax-top-level-await")]),e._v("，是没办法编译成 AST 树的。并且会报 Unexpected reserved word 'await' 这种类似的错误。")]),e._v(" "),s("p",[e._v("3."),s("code",[e._v("babel-plugin-proposal-xx")]),e._v("：用来编译和转换在提案中的属性，在 Plugins List 中可以看到这些插件，比如 "),s("code",[e._v("class-properties")]),e._v("、"),s("code",[e._v("decorators")]),e._v("。")]),e._v(" "),s("h3",{attrs:{id:"babel-polyfill"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#babel-polyfill"}},[e._v("#")]),e._v(" @babel/polyfill")]),e._v(" "),s("p",[e._v("Babel 官方的 polyfill 使用方法主要有如下几种")]),e._v(" "),s("p",[e._v("1.直接在 html 文件引入 Babel 官方的 polyfill.js 脚本文件；")]),e._v(" "),s("p",[e._v("2.在前端工程的入口文件里引入 polyfill.js；")]),e._v(" "),s("p",[e._v("3.在前端工程的入口文件里引入@babel/polyfill；")]),e._v(" "),s("p",[e._v("4.在前端工程的入口文件里引入 core-js/stable 与 regenerator-runtime/runtime；")]),e._v(" "),s("p",[e._v("5.在前端工程构建工具的配置文件入口项引入 polyfill.js；")]),e._v(" "),s("p",[e._v("6.在前端工程构建工具的配置文件入口项引入@babel/polyfill；")]),e._v(" "),s("p",[e._v("7.在前端工程构建工具的配置文件入口项引入 core-js/stable 与 regenerator-runtime/runtime；")]),e._v(" "),s("p",[e._v("从 babel7.4 开始，官方不推荐再使用@babel/polyfill 了，因为@babel/polyfill 本身其实就是两个 npm 包的集合：core-js 与 regenerator-runtime。")]),e._v(" "),s("p",[e._v("官方推荐直接使用这两个 npm 包。虽然@babel/polyfill 还在进行版本升级，但其使用的 core-js 包为 2.x.x 版本，而 core-js 这个包本身已经发布到了 3.x.x 版本了，@babel/polyfill 以后也不会使用 3.x.x 版本的包了。新版本的 core-js 实现了许多新的功能，例如数组的 includes 方法,所以现在直接配置@babel/preset-env，useBuiltIns usage")]),e._v(" "),s("p",[e._v("目前前端需要的配置")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('{\n    "presets": [\n        [\n            "@babel/preset-env",\n            {\n                // 描述您为项目支持/目标的环境\n                "targets": {\n                    "browsers": ["> 1%", "last 2 versions"]\n                },\n                "corejs": 3, //新版本需要指定核⼼库版本\n                "useBuiltIns": "usage", //按需注⼊\n                "modules": false\n            }\n        ]\n    ],\n    "plugins":[\n        "@babel/transform-runtime"\n    ]\n}\n')])])]),s("p",[e._v("如果写个插件 参考"),s("code",[e._v("不可多得的 Babel 小抄")])]),e._v(" "),s("p",[e._v("参考：")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s/lVd-kXDUH7kSwkYQEvQO4Q",target:"_blank",rel:"noopener noreferrer"}},[e._v("不可多得的 Babel 小抄"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://www.jiangruitao.com/babel/babel-node/",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=l.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{455:function(n,e,t){"use strict";t.r(e);var s=t(23),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"_1-栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-栈"}},[n._v("#")]),n._v(" 1.栈")]),n._v(" "),t("p",[n._v("一个先进后出，后进先出的数据结构")]),n._v(" "),t("p",[n._v("按照常识理解就是有序的挤公交，最后上车的人会在门口，然后门口的人会最先下车")]),n._v(" "),t("p",[n._v("js 中没有栈的数据类型，但我们可以通过 Array 来模拟一个")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const stack = [1,2,3,4]\nstack.push(5); //入栈\ncosnt item = stack.pop(); //出栈\n")])])]),t("p",[n._v("使用场景")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("场景一：十进制转二进制")])]),n._v(" "),t("li",[t("p",[n._v("场景二：有效括号")])]),n._v(" "),t("li",[t("p",[n._v("场景三：函数调用堆栈")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('  1.十进制转二进制 ,十进制整数转换为二进制整数采用"除2取余，逆序排列"法。\n  // 时间复杂度 O(n) n为二进制的长度\n  // 空间复杂度 O(n) n为二进制的长度\n\n  const ten2bin = (dec)=>{\n      //创建一个字符串\n      let res = \'\';\n\n      // 创建一个栈stack\n      let stack = [];\n      //遍历数字 如果大于0 就可以继续转换\n\n      while(dec>0){\n          //将数字的余数入栈\n          stack.push(dec%2);\n          // 除以2\n          dec = dec >> 1;\n\n      }\n\n      //取出栈中的数字\n\n      while(stack.length){\n          res += stack.pop()\n      }\n\n      //返回这个字符串\n      return res;\n  }\n\n  2.判断字符串的有效括号  \'(){}[]\'\n\n  有效括号字符串的长度，一定是偶数！\n  右括号前面，必须是相对应的左括号，才能抵消！\n  右括号前面，不是对应的左括号，那么该字符串，一定不是有效的括号！\n\n  const isValid = (s)=>{\n      //如果 长度不等于2的倍数肯定不是一个有效的括号,肯定是偶数\n      if(s.length % 2 === 1) return false;\n      //创建一个栈\n      let stack = [];\n\n      for(let i=0;i<s.length;i++){\n          let c = s[i];\n          //如果左边是括号就入栈\n          if(c === \'(\' || c === \'{\' || c === \'[\'){\n              stack.push(c)\n          }else{\n              // 如果不是左括号 且栈为空 肯定不是一个有效的括号 返回false\n              if (!stack.length) return false;\n              // 拿到最后一个左括号\n              let top = stack[stack.length - 1];\n              if ((top === "(" && c === ")") || (top === "{" && c === "}") || (top === "[" && c === "]")) {\n                  stack.pop();\n              } else {\n\n                  // 否则就不是一个有效的括号\n                  return false\n              }\n          }\n      }\n          //栈为空 表示 是有效的\n      return stack.length === 0;\n\n  }\n')])])])])]),n._v(" "),t("h2",{attrs:{id:"_2-队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-队列"}},[n._v("#")]),n._v(" 2.队列")]),n._v(" "),t("p",[n._v("和栈相反，先进先出的数据结构")]),n._v(" "),t("p",[n._v("按照常识理解就是银行排号办理业务, 先去领号排队的人, 先办理业务")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const queue = [1,2,3];\nqueue.push(5) //入队\nqueue.shift() // 出列\n")])])]),t("p",[n._v("使用场景")]),n._v(" "),t("ul",[t("li",[n._v("场景一：日常测核酸排队")]),n._v(" "),t("li",[n._v("场景二：JS 异步中的任务队列")]),n._v(" "),t("li",[n._v("场景三：计算最近请求次数")])]),n._v(" "),t("p",[t("a",{attrs:{href:"https://leetcode.cn/problems/number-of-recent-calls/solutions/1539471/jsjie-ti-si-lu-qing-xi-ming-liao-by-inte-hnko/",target:"_blank",rel:"noopener noreferrer"}},[n._v("最近的请求次数"),t("OutboundLink")],1)]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    let RecentCounter = function(){\n        this.queue = []\n    }\n\n    RecentCounter.prototype.ping = function(t){\n        this.queue.push(t);\n        while(this.queue[0]<t-3000){\n            this.queue.shift();\n        }\n        return this.queue.length\n    }\n")])])]),t("h2",{attrs:{id:"_3-链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-链表"}},[n._v("#")]),n._v(" 3.链表")]),n._v(" "),t("p",[n._v("多个元素组成的列表，元素存储不连续，通过 next 指针来链接, 最底层为 null")]),n._v(" "),t("p",[n._v("就类似于 父辈链接关系 吧， 比如：你爷爷的儿子是你爸爸，你爸爸的儿子是你，而你假如目前还没有结婚生子，那你就暂时木有儿子")]),n._v(" "),t("p",[t("code",[n._v("js中类似于链表的典型就是原型链, 但是js中没有链表这种数据结构，我们可以通过一个object来模拟链表")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const a = {\n    val:'a'\n}\n\nconst b = {\n    val:'b'\n}\n\nconst c = {\n    val:'c'\n}\n\nconst d = {\n    val:'d'\n}\na.next = b;\nb.next = c;\nc.next = d;\n\nconst linkList = {\n    val:'a',\n    next:{\n        val:'b',\n        next:{\n            val:'c',\n            next:{\n                val:'d',\n                next:null\n            }\n        }\n    }\n}\n\n//循环链表\n\nlet p = a;\nwhile(p){\n    p = p.next;\n}\n//插入\nconst e= {val:'e'};\nc.next = e;\n//删除\nc.next = d;\n")])])]),t("p",[n._v("1）手写 instanceOf")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const myInstanceOf = (A,B)=>{\n    //声明一个指针\n    let p = A;\n\n    //遍历\n    while(p){\n        if(p === B.prototype){ return true};\n        p = p.__ptoto__;\n    }\n\n    return false;\n\n}\n\nmyInstanceOf([],Object)\n")])])]),t("p",[n._v("2）删除链表中的节点")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("const deleteNode = (node) => {\n    // 把当前链表的指针指向下下个链表的值就可以了\n    node.val = node.next.val;\n    node.next = node.next.next\n}\n")])])]),t("p",[n._v("3）删除排序链表中的重复元素")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("// 1->1->2->3->3\n// 1->2->3->null\n\nconst deleteLikn = (head)=>{\n    let p = head;\n\n    while(p&&p.next){\n        // 如果当前节点的值等于下一个节点的值\n        if(p.val === p.next.val){\n            // 删除下一个节点\n            p.next = p.next.next;\n        }else{\n            // 否则继续遍历\n            p = p.next;\n        }\n    }\n    return head\n}\n")])])]),t("p",[n._v("4）反转链表")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("// 1 -> 2 -> 3 -> 4 -> 5 -> null\n// 5 -> 4 -> 3 -> 2 -> 1 -> null\n//双指针\n\nlet reverseLink = (head)=>{\n    let cur = head;\n    let pre = null;\n    while(cur){\n        let tmp = cur.next; // 保存p1 下一个节点，接下来要翻转\n        cur.next = pre;//翻转操作\n        //更新pre 和 cur指针\n        pre = cur;\n        cur= tmp;\n    }\n    return pre\n}\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{433:function(n,t,v){n.exports=v.p+"assets/img/avc.7f6495e5.png"},452:function(n,t,v){"use strict";v.r(t);var l=v(23),_=Object(l.a)({},(function(){var n=this,t=n.$createElement,l=n._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[l("h2",{attrs:{id:"一、基本概念"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#一、基本概念"}},[n._v("#")]),n._v(" 一、基本概念")]),n._v(" "),l("h3",{attrs:{id:"_1-时间复杂度"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-时间复杂度"}},[n._v("#")]),n._v(" 1.时间复杂度")]),n._v(" "),l("p",[n._v("其实就是一个函数，用大 O 表示，O(1)、O(2)、O(n)...")]),n._v(" "),l("p",[n._v("它是用来"),l("code",[n._v("描述算法的运行时间")]),n._v(",什么是时间复杂度")]),n._v(" "),l("p",[n._v("看个栗子")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('function foo1(){\n    console.log("我吃了一颗糖")\n    console.log("我又吃了一颗糖")\n    return "再吃一颗糖"\n}\n')])])]),l("p",[n._v("调用这个函数，里面总执行次数就是 3 次，这个没毛病，都不用算\n那么下面这个栗子呢")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('function foo2(n){\n    for( let i = 0; i < n; i++){\n        console.log("我吃了一颗糖")\n    }\n    return "一颗糖"\n}\n')])])]),l("p",[n._v("那这个函数里面总执行次数呢？根据我们传进去的值不一样，执行次数也就不一样，但是大概次数我们总能知道")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('let = 0 ：执行 1 次\ni < n : 执行 n+1 次\ni++ : 执行 n 次\nconsole.log("执行了") : 执行 n 次\nreturn 1 : 执行 1 次\n')])])]),l("p",[n._v("这个函数的总执行次数就是 3n + 3 次，对吧\n可是我们开发不可能都这样去数，所以根据代码执行时间的推导过程就有一个规律，也就是所有代码执行时间 T(n)和代码的执行次数 f(n) ，这个是成正比的，而这个规律有一个公式")]),n._v(" "),l("p",[n._v("T(n) = O( f(n) )")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v("n 是输入数据的大小或者输入数据的数量\nT(n) 表示一段代码的总执行时间\nf(n) 表示一段代码的总执行次数\nO 表示代码的执行时间 T(n) 和 执行次数 f(n) 成正比\n")])])]),l("p",[n._v("完整的公式看着就很麻烦，别着急，这个公式只要了解一下就可以了，为的就是让你知道我们表示算法复杂度的 O() 是怎么来的，我们平时表示算法复杂度主要就是用 O()，读作大欧表示法，是字母 O 不是零\n只用一个 O() 表示，这样看起来立马就容易理解多了\n回到刚才的两个例子，就是上面的两个函数")]),n._v(" "),l("ul",[l("li",[l("p",[n._v("第一个函数执行了 3 次，用复杂度表示就是 O(3)")])]),n._v(" "),l("li",[l("p",[n._v("第二个函数执行了 3n + 3 次，复杂度就是 O(3n+3)")])])]),n._v(" "),l("p",[n._v("这样有没有觉得还是很麻烦，因为如果函数逻辑一样的，只是执行次数差个几次，像 O(3) 和 O(3)，有什么差别？还要写成两种就有点多此一举了，所以复杂度里有统一的简化的表示法，这个执行时间简化的估算值就是我们最终的时间复杂度")]),n._v(" "),l("p",[n._v("简化的过程如下")]),n._v(" "),l("ul",[l("li",[l("p",[n._v("如果只是常数直接估算为 1，O(3) 的时间复杂度就是 O(1)，不是说只执行了 1 次，而是对常量级时间复杂度的一种表示法。一般情况下，只要算法里没有循环和递归，就算有上万行代码，时间复杂度也是 O(1)")])]),n._v(" "),l("li",[l("p",[n._v("O(3n+4) 里常数 4 对于总执行次数的几乎没有影响，直接忽略不计，系数 3 影响也不大，因为 3n 和 n 都是一个量级的，所以作为系数的常数 3 也估算为 1 或者可以理解为去掉系数，所以 O(3n+3) 的时间复杂度为 O(n)")])]),n._v(" "),l("li",[l("p",[n._v("如果是多项式，只需要保留 n 的最高次项，O( 666n³ + 666n² + n )，这个复杂度里面的最高次项是 n 的 3 次方。因为随着 n 的增大，后面的项的增长远远不及 n 的最高次项大，所以低于这个次项的直接忽略不计，常数也忽略不计，简化后的时间复杂度为 O(n³)")])])]),n._v(" "),l("h4",{attrs:{id:"常用时间复杂度"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常用时间复杂度"}},[n._v("#")]),n._v(" 常用时间复杂度")]),n._v(" "),l("ul",[l("li",[n._v("O(1)")])]),n._v(" "),l("p",[n._v("一般情况下，只要算法里没有循环和递归，就算有上万行代码，时间复杂度也是 O(1)，因为它的执行次数不会随着任何一个变量的增大而变长，比如下面这样")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('function foo(){\n    let n = 1\n    let b = n * 100\n    if(b === 100){\n        console.log("开始吃糖")\n    }\n    console.log("我吃了1颗糖")\n    console.log("我吃了2颗糖")\n    ......\n    console.log("我吃了10000颗糖")\n}\n')])])]),l("ul",[l("li",[n._v("O(n): 如果是 O(1)+O(n) 还是 O(n)")])]),n._v(" "),l("p",[n._v("只有一层循环或者递归等，时间复杂度就是 O(n)，比如下面这样")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('for(let i=0;i<n;i++){\n    console.log(i)\n}\nfunction foo2(n){\n    while( --n > 0){\n        console.log("我吃了一颗糖")\n    }\n}\nfunction foo3(n){\n    console.log("我吃了一颗糖")\n    --n > 0 && foo3(n)\n}\n')])])]),l("ul",[l("li",[n._v("O(n^2)： O(n) * O(n), 也就是双层循环，自此类推：O(n^ 3)... O(n^2)=O(n²)")])]),n._v(" "),l("p",[n._v("嵌套循环，如下面这样的，里层循环执行 n 次，外层循环也执行 n 次，总执行次数就是 n x n，时间复杂度就是 n 的平方，也就是 O(n²)。假设 n 是 10，那么里面的就会打印 10 x 10 = 100 次")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('function foo1(n){\n    for( let i = 0; i < n; i++){\n        for( let j = 0; j < n; j++){\n            console.log("我吃了一颗糖")\n        }\n    }\n}\n')])])]),l("p",[n._v("还有这样的，总执行次数为 n + n²，上面说了，如果是多项式，取最高次项，所以这个时间复杂度也是 O(n²)")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('function foo2(n){\n    for( let k = 0; k < n; k++){\n        console.log("我吃了一颗糖")\n    }\n    for( let i = 0; i < n; i++){\n        for( let j = 0; j < n; j++){\n            console.log("我吃了一颗糖")\n        }\n    }\n}\n\n//或者下面这样，以运行时间最长的，作为时间复杂度的依据，所以下面的时间复杂度就是 O(n²)\nfunction foo3(n){\n    if( n > 100){\n        for( let k = 0; k < n; k++){\n            console.log("我吃了一颗糖")\n        }\n    }else{\n        for( let i = 0; i < n; i++){\n            for( let j = 0; j < n; j++){\n                console.log("我吃了一颗糖")\n            }\n        }\n    }\n}\n')])])]),l("ul",[l("li",[n._v("O(logn)")])]),n._v(" "),l("p",[n._v("假设包糖里有 16 颗，小黑每天吃这一包糖的一半，请问多少天吃完")]),n._v(" "),l("p",[n._v("意思就是 16 不断除以 2，除几次之后等于 1？用代码表示")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v("function foo1(n){\n    let day = 0\n    while(n > 1){\n        n = n/2\n        day++\n    }\n    return day\n}\nconsole.log( foo1(16) ) // 4\n")])])]),l("p",[n._v("循环次数的影响主要来源于 n/2 ，这个时间复杂度就是 O(logn) ，这个复杂度是怎么来的呢，别着急，继续看")]),n._v(" "),l("p",[n._v("再比如下面这样")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('function foo2(n){\n    for(let i = 0; i < n; i *= 2){\n        console.log("一天")\n    }\n}\nfoo2( 16 )\n')])])]),l("p",[n._v("里面的打印执行了 4 次，循环次数主要影响来源于 i *= 2 ，这个时间复杂度也是 O(logn)")]),n._v(" "),l("p",[n._v("这个 O(logn) 是怎么来的，对数，我们看一张图")]),n._v(" "),l("p",[l("img",{attrs:{src:v(433),alt:"图"}})]),n._v(" "),l("p",[n._v("没有理解的话再看一下，理解一下规律")]),n._v(" "),l("ul",[l("li",[l("code",[n._v("真数")]),n._v("：就是真数，这道题里就是 16")]),n._v(" "),l("li",[l("code",[n._v("底数")]),n._v("：就是值变化的规律，比如每次循环都是 i*=2，这个乘以 2 就是规律。比如 1,2,3,4,5...这样的值的话，底就是 1，每个数变化的规律是+1 嘛")]),n._v(" "),l("li",[l("code",[n._v("对数")]),n._v("：在这道题里可以理解成 x2 乘了多少次，这个次数")])]),n._v(" "),l("p",[n._v("仔细观察规律就会发现这道题里底数是 2，而我们要求的天数就是这个对数 4，在对数里有一个表达公式")]),n._v(" "),l("p",[n._v("a^b = n  a 的 b 次方=n，在这道题里我们知道 a 和 n 的值，也就是   2^b = 16 然后求 b")]),n._v(" "),l("p",[n._v("把这个公式转换一下的写法如下")]),n._v(" "),l("p",[n._v("loga^n = b 以 a 为底 n 的对数    在这道题里就是   log2^16 = ?   答案就是 4")]),n._v(" "),l("p",[n._v("公式是固定的，这个 16 不是固定的，是我们传进去的 n，所以可以理解为这道题就是求 log2^n = ?\n用时间复杂度表示就是 O(log2^n)，由于时间复杂度需要去掉常数和系数，而 log 的底数跟系数是一样的，所以也需要去掉，所以最后这个正确的时间复杂度就是 O(logn)")]),n._v(" "),l("p",[n._v("其他还有一些时间复杂度，我由快到慢排列了一下，如下表顺序")]),n._v(" "),l("table",[l("thead",[l("tr",[l("th",[n._v("复杂度")]),n._v(" "),l("th",{staticStyle:{"text-align":"right"}},[n._v("名称")])])]),n._v(" "),l("tbody",[l("tr",[l("td",[n._v("O(1)")]),n._v(" "),l("td",{staticStyle:{"text-align":"right"}},[n._v("常数复杂度")])]),n._v(" "),l("tr",[l("td",[n._v("O(logn)")]),n._v(" "),l("td",{staticStyle:{"text-align":"right"}},[n._v("对数复杂度")])]),n._v(" "),l("tr",[l("td",[n._v("O(n)")]),n._v(" "),l("td",{staticStyle:{"text-align":"right"}},[n._v("线性时间复杂度")])]),n._v(" "),l("tr",[l("td",[n._v("O(nlogn)")]),n._v(" "),l("td",{staticStyle:{"text-align":"right"}},[n._v("线性对数复杂度")])]),n._v(" "),l("tr",[l("td",[n._v("O(n²)")]),n._v(" "),l("td",{staticStyle:{"text-align":"right"}},[n._v("平方")])]),n._v(" "),l("tr",[l("td",[n._v("O(n³)")]),n._v(" "),l("td",{staticStyle:{"text-align":"right"}},[n._v("立方")])]),n._v(" "),l("tr",[l("td",[n._v("O(2n)")]),n._v(" "),l("td",{staticStyle:{"text-align":"right"}},[n._v("指数，一点数据量就卡的不行")])]),n._v(" "),l("tr",[l("td",[n._v("O(n!)")]),n._v(" "),l("td",{staticStyle:{"text-align":"right"}},[n._v("阶乘，就更慢了")])])])]),n._v(" "),l("h3",{attrs:{id:"_2-什么是空间复杂度"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是空间复杂度"}},[n._v("#")]),n._v(" 2.什么是空间复杂度")]),n._v(" "),l("p",[n._v("空间复杂度就是算法需要多少内存，占用了多少空间")]),n._v(" "),l("p",[n._v("常用的空间复杂度有 O(1)、O(n)、O(n²)")]),n._v(" "),l("ul",[l("li",[n._v("O(1)")])]),n._v(" "),l("p",[n._v("只要不会因为算法里的执行，导致额外的空间增长，就算是一万行，空间复杂度也是 O(1)，比如下面这样，时间复杂度也是 O(1)")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v('function foo(){\n    let n = 1\n    let b = n * 100\n    if(b === 100){\n        console.log("开始吃糖")\n    }\n    console.log("我吃了1颗糖")\n    console.log("我吃了2颗糖")\n    ......\n    console.log("我吃了10000颗糖")\n}\n')])])]),l("ul",[l("li",[n._v("O(n)")])]),n._v(" "),l("p",[n._v("比如下面这样，n 的数值越大，算法需要分配的空间就需要越多，来存储数组里的值，所以它的空间复杂度就是 O(n)，时间复杂度也是 O(n)")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v("function foo(n){\n    let arr = []\n    for( let i = 1; i < n; i++ ) {\n        arr[i] = i\n    }\n}\n")])])]),l("ul",[l("li",[n._v("O(n²)")])]),n._v(" "),l("p",[n._v("O(n²) 这种空间复杂度一般出现在比如二维数组，或是矩阵的情况下")]),n._v(" "),l("p",[n._v("不用说，你肯定明白是啥情况啦")]),n._v(" "),l("p",[n._v("就是遍历生成类似这样格式的")]),n._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[n._v("let arr = [\n    [1,2,3,4,5],\n    [1,2,3,4,5],\n    [1,2,3,4,5]\n]\n")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);
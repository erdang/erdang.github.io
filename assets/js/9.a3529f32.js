(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{437:function(t,a,e){"use strict";e.r(a);var i=e(23),s=Object(i.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("版本管理在产品级开发中是非常重要的一个部分，它涉及到团队协作，且影响到产品最终的发布、上线以及测试环节，当前最流行的版本控制系统是 git。git 内容非常多，本文只讲基础和平时工作中常用的命令。")]),t._v(" "),e("h2",{attrs:{id:"git-优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-优势"}},[t._v("#")]),t._v(" git 优势")]),t._v(" "),e("p",[t._v("1、分布式版本管理系统")]),t._v(" "),e("p",[t._v("2、速度快")]),t._v(" "),e("p",[t._v("3、设计简单")]),t._v(" "),e("p",[t._v("4、轻量级的分支操作，允许上千个并行开发的分支，对非线性开发模式的强力支持")]),t._v(" "),e("p",[t._v("5、有能力高效管理类似 linux 内核一样的超大规模项目")]),t._v(" "),e("p",[t._v("6、git 已经成为事实上的标准，几乎所有优秀的前端项目都通过 git 来进行版本控制")]),t._v(" "),e("p",[t._v("7、社区成熟活跃，git 的流行离不开 github 的贡献")]),t._v(" "),e("h2",{attrs:{id:"git-配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-配置"}},[t._v("#")]),t._v(" git 配置")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('取消全局配置    git config --global --unset user.name\n设置全局用户名  git config --global user.name "erdang"\n设置全局邮箱    git config --global user.email "924064382@qq.com"\n查看所有配置    git config --list\n查看全局配置    git config --list --global\n--global 可选 以下  设置本仓库 --global 删除\n--local【默认，高优先级】：只影响本仓库，文件为.git/config\n--global【中优先级】：影响到所有当前用户的git仓库，文件为~/.gitconfig\n--system【低优先级】：影响到全系统的git仓库，文件为/etc/gitconfig\n如果要删除或修改配置，更简单的办法是直接打开~/.gitconfig文件，或者.git/config文件修改即可\n')])])]),e("h3",{attrs:{id:"关于忽略的配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于忽略的配置"}},[t._v("#")]),t._v(" 关于忽略的配置")]),t._v(" "),e("p",[t._v("可以在项目根目录创建一个名为 .gitignore 的文件，列出要忽略的文件模式\n文件 .gitignore 的格式规范如下：")]),t._v(" "),e("p",[t._v("1、所有空行或者以注释符号 ＃ 开头的行都会被 git 忽略")]),t._v(" "),e("p",[t._v("2、可以使用标准的 glob 模式匹配")]),t._v(" "),e("p",[t._v("3、匹配模式以反斜杠(/)开头防止递归")]),t._v(" "),e("p",[t._v("4、匹配模式最后跟反斜杠(/)说明要忽略的是目录")]),t._v(" "),e("p",[t._v("5、要忽略指定模式以外的文件或目录，可以在模式前加上叹号(!)取反")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("node_modules/\necosystem.json\n.DS_Store\n.idea\n.vscode\n")])])]),e("h3",{attrs:{id:"ssh-配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssh-配置"}},[t._v("#")]),t._v(" SSH 配置")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('cd ~/.ssh\nssh-keygen -t rsa -C "your_email@youremail.com"  一路回车\ncat id_rsa.pub\n登陆 gitHub，打开 Settings 中的 SSH Keys 页面\nssh -T git@github.com 测试成功\nHi littlematch0123! You\'ve successfully authenticated, but GitHub does not provide shell access.\n.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，\nid_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人\n\n如果配置 多用户 config  生成新的ssh 之后 需要  ssh-add id_rsa  添加生效\n#github user\nHost git@github.com\nHostname https://github.com/\nUser 924064382@qq.com\nIdentityFile ~/.ssh/id_rsa\n\n#gitlab user\nHost  172.16.27.229:8888\nHostname http://172.16.27.229:8888/\nUser git\nIdentityFile ~/.ssh/id_rsa_1\n')])])]),e("h2",{attrs:{id:"重要概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重要概念"}},[t._v("#")]),t._v(" 重要概念")]),t._v(" "),e("h3",{attrs:{id:"【常用术语】"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【常用术语】"}},[t._v("#")]),t._v(" 【常用术语】")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("repository 仓库\nbranch 分支\nsummary 概要\ntrack 跟踪\nmodify 修改\nstage 暂存区\nstash 暂存\ncommit 提交\npush 推送\npull 拉取加合并\nfetch 拉取\nclone 克隆\namend 修改\nmerge 合并\nconflict 冲突\norigin 起源\nupstream 上游\ndownstream 下游\nverbose 冗长的\nreflog 回流\nrebase 变基\n")])])]),e("h3",{attrs:{id:"【-git-目录】"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【-git-目录】"}},[t._v("#")]),t._v(" 【.git 目录】")]),t._v(" "),e("p",[t._v("每个项目都有一个 git 目录(如果 git clone 出来的话，就是其中.git 的目录)，它是 git 用来保存元数据和对象数据库的地方。这个目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("工作区：就是你在电脑里能看到的目录。")])]),t._v(" "),e("li",[e("p",[t._v("暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\n(索引文件里面包含的是文件的目录树，像一个虚拟的工作区，在这个虚拟工作区的目录树中，记录了文件名、文件的最后修改时间、文件长度、文件类型以及最重要的 SHA-1 值，文件的内容并没有存储在其中。而这个 SHA-1 值就是某个文件的当前版本号。而文件的具体内容是在.git/objects 目录下，你会发现这个目录占用空间比较大，因为它存储着当前项目文件各个版本的内容。)")])]),t._v(" "),e("li",[e("p",[t._v("版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。")])])]),t._v(" "),e("h3",{attrs:{id:"【head-是啥-】"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【head-是啥-】"}},[t._v("#")]),t._v(" 【HEAD 是啥？】")]),t._v(" "),e("p",[t._v("用 HEAD 来表示当前版本，也就是最新的提交，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 HEAD~100")]),t._v(" "),e("p",[t._v("假设，我们现在关闭 git bash 和工作目录，当我们下次再次进入工作目录并且打开 git bash 时，仍然会显示为当前处于 master 分支，\n因为我们上次关闭工作目录之前，已经切换到了 master 分支，当然，如果你之前处于 test 分支，那么当你再次打开工作空间，\n仍然会显示你处于 test 分支。\n"),e("br"),t._v("\ngit 其实就是靠 HEAD 知道我们该处于哪个分支的,HEAD 理解成一个指针\n"),e("br"),t._v("\n通常情况下 HEAD 指针指向我们所在的分支（的分支指针)，间接的指向了当前分支的最新提交\n"),e("br"),t._v("\n.git/HEAD\n"),e("br"),t._v("\n.git/refs/heads")]),t._v(" "),e("p",[t._v("特殊情况下 分离头 HEAD 指针没有指向分支指针，而是直接指向了某个提交 （直接检出一个提交 git checkout 哈希）\n"),e("br"),t._v("\ngit log --oneline --all --graph 命令行中以字符的形式尽量接近图形化的方式展示分支\n分离头的状态就是让我们可以随意的检出某个提交，然后基于这个提交创建一些新提交")]),t._v(" "),e("p",[t._v("git reflog 中记录的就是各种指针的常见操作，对分支指针、HEAD 指针等各种” 指针”（即”引用”）的常见操作都会记录\n"),e("a",{attrs:{href:"https://www.zsythink.net/archives/3412/",target:"_blank",rel:"noopener noreferrer"}},[t._v("HEAD 详细介绍"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"【git-基础操作】"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【git-基础操作】"}},[t._v("#")]),t._v(" 【git 基础操作】")]),t._v(" "),e("h3",{attrs:{id:"git-clone"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-clone"}},[t._v("#")]),t._v(" git clone")]),t._v(" "),e("p",[t._v("克隆仓库的命令格式为")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git clone repo\n")])])]),e("p",[t._v("如果我们需要克隆到指定的目录，可以使用以下命令格式")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git clone <repo> <directory>\n")])])]),e("h3",{attrs:{id:"git-init"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-init"}},[t._v("#")]),t._v(" git init")]),t._v(" "),e("p",[t._v("要对现有的某个项目开始用 git 管理，只需到此项目所在的目录，执行")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git init\n")])])]),e("h3",{attrs:{id:"git-add"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-add"}},[t._v("#")]),t._v(" git add")]),t._v(" "),e("p",[e("code",[t._v("git add")]),t._v(" 命令是个多功能命令，根据目标文件的状态不同，此命令的效果也不同："),e("br"),t._v("\n可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git add text 添加单个到下一次提交中\ngit add . 添加当前目录下所有文件到下一次提交中\n")])])]),e("h3",{attrs:{id:"git-commit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-commit"}},[t._v("#")]),t._v(" git commit")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git commit -m '更新 README 内容'\ngit commit -am '更新 README'  加上 -a 选项，git 会自动把所有已经跟踪过的文件暂存起来一并提交\ngit commit -amend 修改最后一个提交 不会产生新的提交记录\ngit commit -v\n使用 -v 或--verbose选项，翻译成中文是冗余的，它不仅能回顾刚刚修改的内容，而且会迫使把提交理由写得更详细些\n")])])]),e("h3",{attrs:{id:"git-log-与-git-reflog"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-log-与-git-reflog"}},[t._v("#")]),t._v(" git log 与 git reflog")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git log 可以查看提交历史\ngit log --oneline 将每个提交放在一行显示，这在提交数很大时非常有用\ngit log -p -2  -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新\ngit reflog 用来记录每一次命令 各种指针的常见操作\ngit blame <file> 以列表形式显示修改记录指定文件\n")])])]),e("h3",{attrs:{id:"git-diff-查看不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-diff-查看不同"}},[t._v("#")]),t._v(" git diff 查看不同")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git diff 工作目录中当前文件和暂存区域快照之间的差异\ngit diff --cached  看已经暂存起来的文件和上次提交时的快照之间的差异\n")])])]),e("h3",{attrs:{id:"git-status-查看状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-status-查看状态"}},[t._v("#")]),t._v(" git status 查看状态")]),t._v(" "),e("p",[t._v("要确定哪些文件当前处于什么状态，可以用 "),e("code",[t._v("git status")]),t._v("命令"),e("br"),t._v(" "),e("code",[t._v("git status")]),t._v("命令的输出十分详细，但其用语有些繁琐。"),e("br"),t._v("\n如果使用 "),e("code",[t._v("git status -s")]),t._v(" 命令或 "),e("code",[t._v("git status --short")]),t._v(" 命令，将得到一种更为紧凑的格式输出"),e("br"),t._v("\n一般地，-s 选项与-b 选项同时使用，s 代表 summary(概要)，b 代表 branch(分支)")]),t._v(" "),e("h3",{attrs:{id:"git-reset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-reset"}},[t._v("#")]),t._v(" git reset")]),t._v(" "),e("p",[t._v("git reset 命令用于回退版本，可以指定退回某一次提交的版本。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git reset [--soft | --mixed | --hard][HEAD]\n--soft 工作区和暂存区 不会改变\n--hard 工作区和暂存区 都会改变\n--mixed 暂存区改变 工作区不变 默认值\ngit reset HEAD 取消git add 添加\n")])])]),e("h3",{attrs:{id:"分支-git-branch-和-git-checkout"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分支-git-branch-和-git-checkout"}},[t._v("#")]),t._v(" 分支 git branch 和 git checkout")]),t._v(" "),e("p",[t._v("git 中默认分支的名字是"),e("code",[t._v("master")]),t._v("，而"),e("code",[t._v("origin")]),t._v("是 Git 给克隆的仓库服务器的默认名字。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git checkout test 创建分支\ngit checkout test -b 创建分支并切换到当前分支\ngit checkout <remotebranch> origin/<remotebranch> 检出远程分支\ngit checkout -b new test/acc 检出远程 test仓库下 acc分支到本地\ngit checkout --文件 丢弃文件工作区的修改\ngit branch test -d 删除分支\ngit branch test -D 强制删除分支\ngit branch 显示当前所有分支的一个列表\ngit branch -v 可以查看每一个分支的最后一次提交\ngit branch --merged 可以看到已经合并到当前分支的分支列表\n")])])]),e("h3",{attrs:{id:"合并分支-解决冲突"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合并分支-解决冲突"}},[t._v("#")]),t._v(" 合并分支 (解决冲突)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n手动解决完 git add .  提交\ngit merge --abort 退出合并\n")])])]),e("h3",{attrs:{id:"git-rebase"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase"}},[t._v("#")]),t._v(" git rebase")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git rebase [branch] 把分叉的提交变成直线。\ngit log  查看提交记录 然后 找到版本号\ngit reabse -i 哈希 合并提交记录\n按i 进入编辑模式   不需要的 改成s\npick：保留该commit（缩写:p）\nreword：保留该 commit，但我需要修改该 commit 的注释（缩写:r）\nedit：保留该 commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）\nsquash：将该 commit 和前一个 commit 合并（缩写:s）\n")])])]),e("h3",{attrs:{id:"git-fetch-与-git-pull"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-fetch-与-git-pull"}},[t._v("#")]),t._v(" git fetch 与 git pull")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(" git fetch origin master:brantest 命令用于从远程获取代码库\n git fetch 简写\n git fetch -p 命令 删除不存在的远程分支\n git merge [branch] 合并\n git pull == git fetch 加 git merge\n git pull <远程主机名> <远程分支名>:<本地分支名>\n git pull origin master:brantest\n 将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。\n git pull origin master 与当前分支合并\n")])])]),e("h3",{attrs:{id:"git-push"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-push"}},[t._v("#")]),t._v(" git push")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git push <远程主机名> <本地分支名>:<远程分支名>\ngit push --force origin master:master --force强制\ngit push origin --delete master 删除分支\n")])])]),e("h3",{attrs:{id:"git-remote-命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-remote-命令"}},[t._v("#")]),t._v(" git remote 命令")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git remote -v 显示所有远程仓库\norigin 为远程地址的别名\ngit remote show [remote]  显示某个远程仓库的信息\ngit remote add [shortname] [url] 添加远程版本库： shortname 为本地的版本库，\ngit remote add origin git@github.com:tianqixin/runoob-git-test.git\ngit push -u origin master\ngit remote rm name  # 删除远程仓库\ngit remote rename old_name new_name  # 修改仓库名\ngit push --set-upstream origin branch_name\n在远程创建一个与本地branch_name 分支同名的分支并跟踪；\ngit checkout --track origin/branch_name\n来在本地创建一个与 branch_name 同名分支跟踪远程分支\n")])])]),e("h3",{attrs:{id:"删除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除"}},[t._v("#")]),t._v(" 删除")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("git rm text 删除文件\ngit rm -f text 强制删除  -force 强制\ngit rm -rf text 强制删除文件夹 -r 递归\ngit rm --cached text  删除缓存 不被跟踪\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{441:function(s,e,t){"use strict";t.r(e);var a=t(23),r=Object(a.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"fs-模块的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fs-模块的使用"}},[s._v("#")]),s._v(" fs 模块的使用")]),s._v(" "),t("h3",{attrs:{id:"判断文件夹是否存在"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断文件夹是否存在"}},[s._v("#")]),s._v(" 判断文件夹是否存在")]),s._v(" "),t("p",[s._v("通过异步和同步两种方式判断dist目录是否存在")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("const fs = require('fs');\n\nfs.exists('./dist',(result)=>{console.log(result)})\n\nconst exists = fs.existsSync('./dist');\n\nif(exists){\n    console.log('dist目录存在')\n}else{\n    console.log('dist目录不存在')\n}\n")])])]),t("p",[s._v("同步的任务先完成，而异步的任务会延后一些，但是同步任务会导致主线程阻塞，在实际应用过程中需要根据实际应用场景进行取舍")]),s._v(" "),t("h3",{attrs:{id:"创建文件夹"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建文件夹"}},[s._v("#")]),s._v(" 创建文件夹")]),s._v(" "),t("p",[s._v("通过异步的方式创建dist目录：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("fs.exists('./dist',(result)=>{\n    !result && fs.mkdir('./dist')\n})\n")])])]),t("p",[s._v("通过同步的方式创建dist目录：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("if(!fs.existsSync('./dist')){\n    fs.mkdirSync('./dist')\n}\n")])])]),t("h3",{attrs:{id:"读取文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读取文件"}},[s._v("#")]),s._v(" 读取文件")]),s._v(" "),t("p",[s._v("通过异步的方式")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("const fs = require('fs')\n\nfs.readFile('./a.js',(err,file)=>{\n    if (!err) console.log(file.toString()) // 打印文件内容,通过toString()方法可以获取到文件的文本内容： \n})\n")])])]),t("p",[s._v("通过同步方式")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("const file = fs.readFileSync('./a.js');\n\nconsole.log(file.toString()) \n")])])]),t("h3",{attrs:{id:"写入文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写入文件"}},[s._v("#")]),s._v(" 写入文件")]),s._v(" "),t("h4",{attrs:{id:"覆盖写入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#覆盖写入"}},[s._v("#")]),s._v(" 覆盖写入")]),s._v(" "),t("p",[s._v("通过异步的方式")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("const fs = require('fs')\n\nfs.readFile('./a.js',(err,file)=>{\n    if (!err)fs.writeFile('./dist/a.js',file,()=>{\n        console.log('写入成功') // 写入成功的回调,默认会覆盖\n    }) \n})\n")])])]),t("p",[s._v("通过同步方式")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("const file = fs.readFileSync('./a.js');\nfs.writeFileSync('./dist/index.js', file) // 同步写入文件\n")])])]),t("h4",{attrs:{id:"追加写入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#追加写入"}},[s._v("#")]),s._v(" 追加写入")]),s._v(" "),t("p",[s._v("很多时候我们需要在文件末尾追加写入一些内容，可以增加flag属性进行标识，当flag的值为a时，表示追加写入：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("const file = fs.readFileSync('./a.js');\nfs.writeFileSync('./dist/index.js', file,{flag:'a'}) // 同步写入文件\n")])])]),t("h2",{attrs:{id:"path的基本应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#path的基本应用"}},[s._v("#")]),s._v(" path的基本应用")]),s._v(" "),t("h3",{attrs:{id:"生成绝对路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成绝对路径"}},[s._v("#")]),s._v(" 生成绝对路径")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("const path = require('path')\n\nconsole.log(path.resolve('./dist/index.js'))\nconsole.log(path.resolve('src', 'vue/path/index.js'))\nconsole.log(path.resolve('/src', '/vue/path/index.js'))\nconsole.log(path.resolve('/src', 'vue/path/index.js'))\n\n/Users/sam/WebstormProjects/rollup-test/dist/index.js\n/Users/sam/WebstormProjects/rollup-test/src/vue/path/index.js\n/vue/path/index.js\n/src/vue/path/index.js\n从左往右依次拼装路径；\n如果参数为相对路径，则会将相对路径拼接起来，再加上当前目录的绝对路径合并成一个完整路径；\n如果参数为绝对路径，则会以最后一个参数的绝对路径为准；\n如果参数既有绝对路径也有相对路径，则会按照从左向后的顺序进行拼接。\n")])])]),t("h3",{attrs:{id:"生成相对路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成相对路径"}},[s._v("#")]),s._v(" 生成相对路径")]),s._v(" "),t("p",[s._v("path.relative(a, b)")]),s._v(" "),t("h2",{attrs:{id:"buble的基本应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#buble的基本应用"}},[s._v("#")]),s._v(" buble的基本应用")]),s._v(" "),t("p",[s._v("buble是一款类似babel的ES编译器，它的主要特性如下：")]),s._v(" "),t("ul",[t("li",[s._v("无配置，没有plugins和preset的概念，可扩展性较低，但简单易用。")]),s._v(" "),t("li",[s._v("相对较小，速度更快。")]),s._v(" "),t("li",[s._v("避免无法在ES2015中表达的代码，如for...of。buble不支持的功能列表："),t("a",{attrs:{href:"https://buble.surge.sh/guide/#unsupported-features",target:"_blank",rel:"noopener noreferrer"}},[s._v("buble.surge.sh"),t("OutboundLink")],1)])]),s._v(" "),t("h2",{attrs:{id:"flow的基本应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flow的基本应用"}},[s._v("#")]),s._v(" flow的基本应用")]),s._v(" "),t("p",[s._v("flow是Javascript静态代码类型检查器")]),s._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("ul",[t("li",[s._v("fs模块：Node.js内置模块，用于本地文件系统处理；")]),s._v(" "),t("li",[s._v("path模块：Node.js内置模块，用于本地路径解析；")]),s._v(" "),t("li",[s._v("buble模块：用于ES6+语法编译；")]),s._v(" "),t("li",[s._v("flow模块：用于Javascript源码静态检查；")]),s._v(" "),t("li",[s._v("zlib模块：Node.js内置模块，用于使用gzip算法进行文件压缩；")]),s._v(" "),t("li",[s._v("terser模块：用于Javascript代码压缩和美化。")])]),s._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/post/6844903721051095048#heading-16",target:"_blank",rel:"noopener noreferrer"}},[s._v("前置学习之基础知识篇"),t("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);
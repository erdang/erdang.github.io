(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{454:function(t,s,e){"use strict";e.r(s);var a=e(23),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、数组常见的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、数组常见的方法"}},[t._v("#")]),t._v(" 一、数组常见的方法")]),t._v(" "),e("h3",{attrs:{id:"_1-push"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-push"}},[t._v("#")]),t._v(" 1.push()")]),t._v(" "),e("p",[t._v("尾部添加，类似压栈,原数组会变")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("let arr = [1,2,3]\narr.push(5);\nconsle.log(arr) // 1,2,3,5\n")])])]),e("h3",{attrs:{id:"_2-pop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-pop"}},[t._v("#")]),t._v(" 2.pop()")]),t._v(" "),e("p",[t._v("尾部删除，类似出栈，原数组会变。数组的 push && pop 可以模拟常见的数据结构栈，先进后出，后进先出")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("let arr = [1,2,3];\narr.pop();\nconsole.log(arr) //[ 1,2]\n\n//模拟栈\nconst stack = [1,2];\nstack.push(3);//压栈\nconsole.log(stack) //[1,2,3]\n\nconst popValue = stack.pop();\nconsle.log(popValue) // 3\nconsle.log(stack) // [1,2]\n")])])]),e("h3",{attrs:{id:"_3-unshift"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-unshift"}},[t._v("#")]),t._v(" 3.unshift()")]),t._v(" "),e("p",[t._v("头部添加，类似入队，原数组会变")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("let arr = [1,2,3];\narr.unshift(0);\nconsole.log(arr) // [0,1,2,3]\n")])])]),e("h3",{attrs:{id:"_4-shift"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-shift"}},[t._v("#")]),t._v(" 4.shift()")]),t._v(" "),e("p",[t._v("头部删除，原数组会变，push && shift 可以模拟常见的数据结构队列，先进先出，后进后出")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [1,2,3]\nconst shfitVal = arr.shift();\nconsole.log(shfitVal) //1\nconsle.log(arr) //[2,3]\n\n//模拟队列\n\nconst queue = [0,1]\nqueue.push(2);\nconsle.log(arr) //[0,1,2]\n\nconst shiftVal = queue.shift();\nconsole.log(shiftVal) //0\nconsle.log(arr) //[1,2]\n")])])]),e("h3",{attrs:{id:"_5-concat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-concat"}},[t._v("#")]),t._v(" 5.concat()")]),t._v(" "),e("p",[t._v("concat 会在当前数组尾部拼接传入的数组，返回一个新的数组，原数组不变")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [1,2,3]\nconst arr2 = arr.concat([4,5])\nconsole.log(arr) // [1,2,3]\nconsole.log(arr2) // [1,2,3,4,5]\n")])])]),e("h3",{attrs:{id:"_6-indexof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-indexof"}},[t._v("#")]),t._v(" 6.indexOf()")]),t._v(" "),e("p",[t._v("在数组中寻找该值，找到返回其下标，找不到返回-1")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [ 1,2,3,4]\nconsle.log(arr.indexOf(7)) // -1\nconsle.log(arr.indexOf(2)) // 1\n")])])]),e("h3",{attrs:{id:"_7-includes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-includes"}},[t._v("#")]),t._v(" 7.includes()")]),t._v(" "),e("p",[t._v("在数组中寻找该值，找到返回 true,没找到返回 false")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [1,2,3]\nconsle.log(arr.includes(5)) //false\nconsle.log(arr.includes(1)) //true\n")])])]),e("h3",{attrs:{id:"_8-join"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-join"}},[t._v("#")]),t._v(" 8.join()")]),t._v(" "),e("p",[t._v("将数组转化为字符串，并返回该字符串，不传值则默认逗号分开，原数组不变")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [1,2,3]\nconsole.log(arr.join()) // 1,2,3\nconsole.log(arr) //[ 1,2,3]\n")])])]),e("h3",{attrs:{id:"_9-reverse"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-reverse"}},[t._v("#")]),t._v(" 9.reverse()")]),t._v(" "),e("p",[t._v("翻转原数组，并返回翻转的数组，原数组改变")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [1,2,3]\nconsole.log(arr.reverse())// [3,2,1]\nconsole.log(arr) //[3,2,1]\n")])])]),e("h3",{attrs:{id:"_10-slice-start-end"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-slice-start-end"}},[t._v("#")]),t._v(" 10.slice(start,end)")]),t._v(" "),e("p",[t._v("从 start 开始截取到 end，不包括 end")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [1,2,3]\nconsle.log(arr.slice(1,2)) //[2,3]\nconsle.log(arr) // [1,2,3]\n\n//如果start是负数，则start = max(length + start,0)\n//如果 end 是负数，则 end = max(length + end,0)\n//如果没有参数，则返回原数组\n\narr.slice(0) // [1,2,3] 从start 到结束\n")])])]),e("h3",{attrs:{id:"_11-splice-start-deletecount-item1-item2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-splice-start-deletecount-item1-item2"}},[t._v("#")]),t._v(" 11.splice(start,deleteCount,item1,item2....)")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("start 开始的位置")])]),t._v(" "),e("li",[e("p",[t._v("deleteCount 要截取的个数")])]),t._v(" "),e("li",[e("p",[t._v("itme1,itme2.... 添加的元素")])]),t._v(" "),e("li",[e("p",[t._v("改变原数组")])]),t._v(" "),e("li",[e("p",[t._v("如果 deleteCount=0，表示不删除元素，如果 item1,item2.... 没有，表示从 start 开始截取到结束，如果有，表示从 start 开始添加")])]),t._v(" "),e("li",[e("p",[t._v("返回值为被删除的元素组成的数组，如果没删除返回空数组")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('  const arr3 = [1,2,3,4,5,6,7,"f1","f2"]\n  const arr4 = arr3.splice(2,3)\n  console.log(arr4) // [3,4,5]\n  console.log(arr3) // [1,2,6,7,"f1","f2"]\n  const arr5 = arr3.splice(2, 0, "wu", "leon");\n  // 从第2位开始删除0个元素，插入"wu","leon"\n  console.log(arr5); // [] 返回空数组\n  console.log(arr3); // [1, 2, "wu", "leon", 6, 7, "f1", "f2"]; 原始数组被改变\n\n  const arr6 = arr3.splice(2, 3, "xiao", "long");\n  // 从第 2 位开始删除 3 个元素，插入"xiao", "long"\n  console.log(arr6); // ["wu", "leon", 6]\n  console.log(arr3); //[ 1, 2, "xiao", "long", 7, "f1", "f2"]\n\n  const arr7 = arr3.splice(2); // 从第三个元素开始删除所有的元素\n  console.log(arr7);// ["xiao", "long", 7, "f1", "f2"]\n  console.log(arr3); // [1, 2]\n')])])])])]),t._v(" "),e("h3",{attrs:{id:"_12-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-sort"}},[t._v("#")]),t._v(" 12.sort()")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("对数组的元素进行排序，并返回数组。")])]),t._v(" "),e("li",[e("p",[t._v("默认情况下，sort()方法按字符串升序排列数组项，sort 方法会调用每个数组项的 toString()方法，然后比较得到的字符串排序，返回经过排序之后的数组，而原数组顺序也发生改变")])]),t._v(" "),e("li",[e("p",[t._v("接受一个比较函数作为参数，以便指定哪个值在哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个参数之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("  const arr = [1, 2, 3]\n  arr.sort((a, b) => b - a)\n  console.log(arr) // [3, 2, 1]\n")])])])])]),t._v(" "),e("h3",{attrs:{id:"_13-tostoring"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-tostoring"}},[t._v("#")]),t._v(" 13.toStoring()")]),t._v(" "),e("p",[t._v("将数组转化成字符串，并返回该字符串，逗号隔开，原数组不变。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [1, 2, 3, 4, 5]\nconsole.log(arr.toString()) // ‘1, 2, 3, 4, 5’\nconsole.log(arr) // [1, 2, 3, 4, 5]\n")])])]),e("h2",{attrs:{id:"二、字符串常用方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、字符串常用方法"}},[t._v("#")]),t._v(" 二、字符串常用方法")]),t._v(" "),e("h3",{attrs:{id:"_1-chartat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-chartat"}},[t._v("#")]),t._v(" 1.chartAt()")]),t._v(" "),e("p",[t._v("返回指定索引位置处的字符。类似于数组用中括号获取相应下标位置的数据。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var str = 'abcdefg'\nconsole.log(str.charAt(2)) // 输出 'c'\nconsole.log(str[2]) // 输出 'c'\n")])])]),e("h3",{attrs:{id:"_2-concat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-concat"}},[t._v("#")]),t._v(" 2.concat()")]),t._v(" "),e("p",[t._v("类似数组的 concat()，用来返回一个合并拼接两个或两个以上字符串。原字符串不变。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const str1 = 'abcdefg'\nconst str2 = '1234567'\nconst str3 = str1.concat(str2)\nconsole.log(str3) // 输出 'abcdefg1234567'\n")])])]),e("h3",{attrs:{id:"_3-indexof-、lastindexof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-indexof-、lastindexof"}},[t._v("#")]),t._v(" 3.indexOf()、lastIndexOf()")]),t._v(" "),e("p",[e("code",[t._v("indexOf")]),t._v(",返回一个字符在字符串中首次出现的位置,"),e("code",[t._v("lastIndexOf")]),t._v("返回一个字符在字符串中最后一次出现的位置。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const str = 'abcdcefcg'\nconsole.log(str.indexOf('c')) // 输出 '2'\nconsole.log(str.lastIndexOf('c')) // 输出 '7'\n")])])]),e("h3",{attrs:{id:"_4-slice-start-end-同数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-slice-start-end-同数组"}},[t._v("#")]),t._v(" 4.slice(start,end) 同数组")]),t._v(" "),e("p",[t._v("提取字符串的片断，并把提取的字符串作为新的字符串返回出来。原字符串不变。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const str = 'abcdefg'\nconsole.log(str.slice()) // 输出 'abcdefg', 不传递参数默认复制整个字符串\nconsole.log(str.slice(1)) // 输出 'bcdefg',传递一个，则为提取的起点，然后到字符串结尾\nconsole.log(str.slice(2, str.length-1)) // 输出'cdef',传递两个，为提取的起始点和结束点\n")])])]),e("h3",{attrs:{id:"_5-split"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-split"}},[t._v("#")]),t._v(" 5.split()")]),t._v(" "),e("p",[t._v("使用指定的分隔符将一个字符串拆分为多个子字符串数组并返回，原字符串不变 默认逗号")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('const str = \'A*B*C*D*E*F*G\'\nconsole.log(str.split(\'*\')) // 输出 ["A", "B", "C", "D", "E", "F", "G"]\n')])])]),e("h3",{attrs:{id:"_6-substr-substring"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-substr-substring"}},[t._v("#")]),t._v(" 6.substr(),substring()")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("这两个方法的功能都是截取一个字符串的片段，并返回截取的字符串。")])]),t._v(" "),e("li",[e("p",[t._v("substr 和 substring 这两个方法不同的地方就在于参数二，substr 的参数二是截取返回出来的这个字符串指定的长度，substring 的参数二是截取返回这个字符串的结束点，并且不包含这个结束点。而它们的参数一，都是一样的功能，截取的起始位置。")])]),t._v(" "),e("li",[e("p",[t._v("注意事项：substr 的参数二如果为 0 或者负数，则返回一个空字符串，如果未填入，则会截取到字符串的结尾去。substring 的参数一和参数二为 NAN 或者负数，那么它将被替换为 0。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("  const str = 'ABCDEFGHIJKLMN'\n  console.log(str.substr(2)) // 输出 'CDEFGHIJKLMN'\n  console.log(str.substring(2)) // 输出 'CDEFGHIJKLMN'\n\n  console.log(str.substr(2, 9)) // 输出 'CDEFGHIJK'\n  console.log(str.substring(2, 9)) // 输出 'CDEFGHI'\n")])])])])]),t._v(" "),e("h3",{attrs:{id:"_7-match"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-match"}},[t._v("#")]),t._v(" 7.match()")]),t._v(" "),e("p",[t._v("match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，并返回一个包含该搜索结果的数组。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const str = '2018年结束了，2019年开始了，2020年就也不远了'\nconst reg = /\\d+/g  // 这里是定义匹配规则，匹配字符串里的1到多个数字\nconsole.log(str.match(reg))  // 输出符合匹配规则的内容，以数组形式返回 ['2018', '2019', '2020']\nconsole.log(str.match('20'))  // 不使用正则 [\"20\", index: 0, input: \"2018年结束了，2019年开始了\"]\n")])])]),e("p",[t._v("注意事项:如果 match 方法没有找到匹配，将返回 null。如果找到匹配，则 match 方法会把匹配到以数组形式返回，如果正则规则未设置全局修饰符 g，则 match 方法返回的数组有两个特性：input 和 index。input 属性包含整个被搜索的字符串。index 属性包含了在整个被搜索字符串中匹配的子字符串的位置。")]),t._v(" "),e("h3",{attrs:{id:"_8-replace"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-replace"}},[t._v("#")]),t._v(" 8.replace()")]),t._v(" "),e("p",[t._v("replace 接收两个参数，参数一是需要替换掉的字符或者一个正则的匹配规则，参数二，需要替换进去的字符，仔实际的原理当中，参数二，你可以换成一个回调函数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const str = '2018年结束了，2019年开始了，2020年就也不远了'\nconst rex = /\\d+/g  // 这里是定义匹配规则，匹配字符串里的1到多个数字\nconst str1 = str.replace(rex, '****')\nconsole.log(str1) // 输出：\"****年结束了，****年开始了,****年也不远了\"\nconst str2 = str.replace(rex, function(item){\n    console.log(arguments)  // 看下面的图片\n    const arr = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']\n    let newStr = ''\n    item.split('').map(function(i){\n            newStr += arr[i]\n    })\n    return newStr\n})\nconsole.log(str2) // 输出：贰零壹捌年结束了，贰零壹玖年开始了,贰零贰零年也不远了\n")])])]),e("h3",{attrs:{id:"_9-search"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-search"}},[t._v("#")]),t._v(" 9.search()")]),t._v(" "),e("p",[t._v("在目标字符串中搜索与正则规则相匹配的字符，搜索到，则返回第一个匹配项在目标字符串当中的位置，没有搜索到则返回一个-1。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const str = '2018年结束了，2019年开始了，2020年就也不远了'\nconst reg = /\\d+/i  // 这里是定义匹配规则,匹配字符串里的1到多个数字\nconsole.log(str.search(reg)) // 输出 0  这里搜索到的第一项是从位置0开始的\n")])])]),e("h3",{attrs:{id:"_10-tolowercase-touppercase"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-tolowercase-touppercase"}},[t._v("#")]),t._v(" 10.toLowerCase(),toUpperCase()")]),t._v(" "),e("p",[t._v("toLowerCase 把字母转换成小写，toUpperCase()则是把字母转换成大写。")]),t._v(" "),e("h3",{attrs:{id:"_11-includes-startswith-endswith"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-includes-startswith-endswith"}},[t._v("#")]),t._v(" 11.includes(), startsWith(), endsWith()")]),t._v(" "),e("p",[t._v("includes、startsWith、endsWith，es6 的新增方法，includes 用来检测目标字符串对象是否包含某个字符，返回一个布尔值，startsWith 用来检测当前字符是否是目标字符串的起始部分，相对的 endwith 是用来检测是否是目标字符串的结尾部分。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const str = 'Excuse me, how do I get to park road?'\nconsole.log(str.includes('how')) // 输出：true\nconsole.log(str.startsWith('Excuse')) // 输出： true\nconsole.log(str.endsWith('?')) // 输出： true\n")])])]),e("h3",{attrs:{id:"_12-repeat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-repeat"}},[t._v("#")]),t._v(" 12.repeat()")]),t._v(" "),e("p",[t._v("返回一个新的字符串对象，新字符串等于重复了指定次数的原始字符串。接收一个参数，就是指定重复的次数。原字符串不变。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const str = 'http'\nconst str2 = str.repeat(3)\nconsole.log(str) // 输出：'http'\nconsole.log(str2) // 输出：'httphttphttp'\n")])])]),e("h2",{attrs:{id:"三、常用遍历方法-高阶函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、常用遍历方法-高阶函数"}},[t._v("#")]),t._v(" 三、常用遍历方法&高阶函数")]),t._v(" "),e("h3",{attrs:{id:"_1-for"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-for"}},[t._v("#")]),t._v(" 1.for()")]),t._v(" "),e("p",[t._v("最常用的 for 循环，经常用的数组遍历，也可以遍历字符串。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("const arr = [1, 2, 3]\nconst str = 'abc'\nfor (let i = 0; i < arr.length; i++) {\n    console.log(arr[i])\n    console.log(str[i])\n}\n")])])]),e("h3",{attrs:{id:"_2-while-do-while"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-while-do-while"}},[t._v("#")]),t._v(" 2.while() / do while()")]),t._v(" "),e("p",[t._v("while、do while 主要的功能是，当满足 while 后边所跟的条件时，来执行相关业务。这两个的区别是，while 会先判断是否满足条件，然后再去执行花括号里面的任务，而 do while 则是先执行一次花括号中的任务，再去执行 while 条件，判断下次还是否再去执行 do 里面的操作。也就是说 do while 至少会执行一次操作.")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("while(条件){\n    执行...\n}\n------------\ndo{\n    执行...\n}\nwhile(条件)\n")])])]),e("h3",{attrs:{id:"_3-foreach-self-index-arr-this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-foreach-self-index-arr-this"}},[t._v("#")]),t._v(" 3.forEach((self,index,arr)=>{},this)")]),t._v(" "),e("p",[t._v("数组中的每一项运行给定函数，这个方法没有返回值")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("接受一个必须的回调函数参数，第二个参数还可以接受一个可选的上下文参数(改变回调函数里面的 this 指向)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("  const arr = [5,1,3,7,4]\n  arr.forEach((item, index) => {\n  if (item < 2) return\n      console.log(`索引：${index}，数值：${item}`)\n      arr[5] = 0\n  })\n  console.log(arr)\n\n  for循环和forEach 的区别,\n\n  for :\n      - 一个可遍历迭代对象的方法，\n      - 可以控制循环起点,\n      - 可中断 break return continue 对函数进行中断或跳出循环,\n  forEach:\n      -是一个迭代器，不能中断,return 并不会报错，但是不会生效\n  性能比较：for > forEach > map\n\n  for循环没有额外的函数调用栈和上下文，所以它的实现最为简单。\n  forEach：对于forEach来说，它的函数签名中包含了参数和上下文，所以性能会低于 for 循环。\n  map：map 最慢的原因是因为 map 会返回一个新的数组，数组的创建和赋值会导致分配内存空间，因此会带来较大的性能开销\n")])])])])]),t._v(" "),e("h3",{attrs:{id:"_4-for-in"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-for-in"}},[t._v("#")]),t._v(" 4.for...in")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("for...in 是 ES5 标准， 此方法遍历数组效率低，主要是用来循环遍历对象的属性。")])]),t._v(" "),e("li",[e("p",[t._v('遍历数组的缺点：数组的下标 index 值是数字，for-in 遍历的 index 值"0","1","2"等是字符串。')])]),t._v(" "),e("li",[e("p",[t._v("Object.defineProperty，建立的属性，默认不可枚举。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("  const foo = {\n      name: 'bar',\n      sex: 'male'\n  }\n  Object.defineProperty(foo, \"age\", { value : 18 })\n  for(const key in foo){\n      console.log(`可枚举属性：${key}`)\n  }\n  console.log(`age属性：${foo.age}`)\n")])])])])]),t._v(" "),e("h3",{attrs:{id:"_5-for-of"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-for-of"}},[t._v("#")]),t._v(" 5.for...of")]),t._v(" "),e("p",[t._v("for…of 是 ES6 新增的方法，但是 for…of 不能去遍历普通的对象，for…of 的好处是可以使用 break 跳出循环。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("for-of 这个方法避开了 for-in 循环的所有缺陷")])]),t._v(" "),e("li",[e("p",[t._v("与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句")])]),t._v(" "),e("li",[e("p",[t._v("for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM NodeList 对象。")])]),t._v(" "),e("li",[e("p",[t._v("for-of 循环也支持字符串遍历")])])]),t._v(" "),e("p",[t._v("for...in 和 for...of 区别？")]),t._v(" "),e("p",[t._v("简单来说，for of 遍历键值对的键，for in 遍历键值对的值")]),t._v(" "),e("p",[t._v("（1）for…in 用于可枚举数据，如对象、数组、字符串\n（2）for…of 用于可迭代数据，如数组、字符串、Map、Set")]),t._v(" "),e("h3",{attrs:{id:"_6-every-some"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-every-some"}},[t._v("#")]),t._v(" 6.every / some")]),t._v(" "),e("p",[t._v("返回一个布尔值。当我们需要判定数组中的元素是否都满足某些条件时，可以使用 every / some。\n这两个的区别是，every 会去遍历判断是否数组中的每一项都满足条件，遇到不满足的直接停止遍历返回 false，\n而 some 则是当某一项满足条件时停止遍历，返回 true。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("// every\nconst foo = [5,1,3,7,4].every((item, index) => {\n    console.log(`索引：${index}，数值：${item}`)\n    return item > 2\n})\nconsole.log(foo)\n// every 打印：\n// 索引：0，数值：5\n// 索引：1，数值：1\n// false\n\n// some\nconst foo = [5,1,3,7,4].some((item, index) => {\n    console.log(`索引：${index}，数值：${item}`)\n    return item > 2\n})\nconsole.log(foo)\n// some 打印：\n// 索引：0，数值：5\n// true\n")])])]),e("h3",{attrs:{id:"_7-filter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-filter"}},[t._v("#")]),t._v(" 7.filter()")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("filter 方法用于过滤数组成员，满足条件的成员组成一个新数组返回。")])]),t._v(" "),e("li",[e("p",[t._v("它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。")])]),t._v(" "),e("li",[e("p",[t._v("该方法不会改变原数组。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("  const foo = [5,1,3,7,4].filter((item,index) => {\n      console.log(`索引：${index}，数值：${item}`)\n      return item > 2\n  })\n  console.log(foo)\n  // 打印结果：\n  // 索引：0，数值：5\n  // 索引：1，数值：1\n  // 索引：2，数值：3\n  // 索引：3，数值：7\n  // 索引：4，数值：4\n  // [5, 3, 7, 4]\n")])])])])]),t._v(" "),e("h3",{attrs:{id:"_8-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-map"}},[t._v("#")]),t._v(" 8.map()")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("map 即是 “映射”的意思 ，原数组被“映射”成对应新数组。")])]),t._v(" "),e("li",[e("p",[t._v("map：支持 return，相当与原数组克隆了一份，把克隆的每项改变了，也不影响原数组。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("  const foo = [5,1,3,7,4].map((item,index) => {\n      console.log(`索引：${index}，数值：${item}`)\n      return item + 2\n  })\n  console.log(foo)\n")])])])])]),t._v(" "),e("h3",{attrs:{id:"_9-reduce-prev-cur-index-array-reduceright"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-reduce-prev-cur-index-array-reduceright"}},[t._v("#")]),t._v(" 9. reduce(prev, cur, index, array) / reduceRight()")]),t._v(" "),e("p",[t._v("reduce 从左到右将数组元素做“叠加”处理，返回一个值。reduceRight 从右到左。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var a = [1,2,3,4,5];\nvar sum = a.reduce(function(x,y){return x+y},0);//数组求和\nvar product = a.reduce(function(x,y){return x*y},1);//数组求积\nvar max = a.reduce(function(x,y){return (x>y)?x:y;});//求最大值\n")])])]),e("p",[t._v("以上遍历方法的区别：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("一：map()，forEach()，filter()循环的共同之处：\n1.forEach，map，filter循环中途是无法停止的，总是会将所有成员遍历完。\n2.他们都可以接受第二个参数，用来绑定回调函数内部的 this 变量，将回调函数内部的 this 对象，指向第二个参数，间接操作这个参数（一般是数组）。\n\n二：map()、filter()循环和forEach()循环的不同：\nforEach 循环没有返回值； map，filter 循环有返回值。\n\n三：map()和filter()都会跳过空位，for 和 while 不会\n\n四：some()和every():\nsome()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.\n\n五：reduce()，reduceRight()：\nreduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员）。\n\n六：Object对象的两个遍历 Object.keys 与 Object.getOwnPropertyNames：\n他们都是遍历对象的属性，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但Object.keys不能返回不可枚举的属性；Object.getOwnPropertyNames能返回不可枚举的属性\n")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{438:function(t,r,a){"use strict";a.r(r);var e=a(23),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"ast-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ast-是什么"}},[t._v("#")]),t._v(" AST 是什么")]),t._v(" "),a("p",[t._v("抽象语法树(Abstract Syntax Tree),简称 AST,它是源代码语法结构的抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer"}},[t._v("astexplorer"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"ast-可以做什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ast-可以做什么"}},[t._v("#")]),t._v(" AST 可以做什么")]),t._v(" "),a("p",[t._v("1.代码语法的检查、代码风格的检查、代码格式化、代码高亮、代码错误提示、代码自动补全等")]),t._v(" "),a("ul",[a("li",[t._v("如 JSLint、JSHint 对代码错误或风格的检查，发现一些潜在错误 IDE 的错误提示、格式化、高亮、自动补全等")])]),t._v(" "),a("p",[t._v("2.代码混淆压缩")]),t._v(" "),a("ul",[a("li",[t._v("UglifyJS2 等")])]),t._v(" "),a("p",[t._v("3.优化变更代码，改变代码结构使其达到想要的结构")]),t._v(" "),a("ul",[a("li",[t._v("代码打包工具 webpack、rollup 等 CommonJS、AMD、CMD、UMD 等代码规范之间的转化 CoffeeScript、TypeScript、JSX 等转化为原生 Javascript")])]),t._v(" "),a("h3",{attrs:{id:"ast-如何生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ast-如何生成"}},[t._v("#")]),t._v(" AST 如何生成")]),t._v(" "),a("p",[t._v("AST是通过"),a("code",[t._v("JS Parser")]),t._v(" （解析器），将js源码转化为抽象语法树，主要分为两步")]),t._v(" "),a("p",[t._v("JS Parser 是 js 语法解析器，它可以将 js 源码转成 AST，常见的 Parser 有 esprima、traceur、acorn、shift 等。")]),t._v(" "),a("h4",{attrs:{id:"_1-分词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-分词"}},[t._v("#")]),t._v(" 1.分词")]),t._v(" "),a("p",[t._v("将整个的代码字符串，分割成语法单元数组（token）。 JS中的语法单元（token）指标识符（function，return），运算符，括号，数字，字符串等能解析的最小单元。主要有以下几种：")]),t._v(" "),a("ul",[a("li",[t._v("标识符")])]),t._v(" "),a("p",[t._v("没有被引号括起来的连续字符，可以包含字母、数字、_、$，其中数字不能作为开头。\n标识符可能是var，return，function等关键字，也可能是true，false这样的内置常量，或是一个变量。具体是哪种语义，分词阶段不区分，只要正确拆分即可。")]),t._v(" "),a("ul",[a("li",[t._v("数字")])]),t._v(" "),a("p",[t._v("十六进制，十进制，八进制以及科学表达式等都是最小单元")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("运算符： +、-、 *、/ 等")])]),t._v(" "),a("li",[a("p",[t._v("字符串 对计算机而言，字符串只会参与计算和展示，具体里面细分没必要分析")])]),t._v(" "),a("li",[a("p",[t._v("注释  不管是行注释还是块注释，对于计算机来说并不关心其内容，所以可以作为不可再拆分的最小单元")])]),t._v(" "),a("li",[a("p",[t._v("空格 连续的空格，换行，缩进等，只要不在字符串中都没有实际的逻辑意义，所以连续的空格可以作为一个语法单元。")])]),t._v(" "),a("li",[a("p",[t._v("其他，大括号，中括号，小括号，冒号 等等。")])])]),t._v(" "),a("h4",{attrs:{id:"语法分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法分析"}},[t._v("#")]),t._v(" 语法分析")]),t._v(" "),a("p",[t._v("语法分析的目的是将分词得到的语法单元进行一个整体的组合，分析确定语法单元之间的关系。\n简单来说，语法分析可以理解成对语句（statement）和表达式（expression）的识别。")]),t._v(" "),a("p",[t._v("语句，一个具备边界的代码区域。相邻的两个语句之间从语法上讲互不影响。比如： var a = 1; if(xxx){xxx}\n表达式，指最终会有一个结果的一小段代码，它可以嵌入到另一个表达式中，且包含在表达式中。比如：a++， i > 0 && i< 6")]),t._v(" "),a("p",[t._v("语义分析是一个递归的过程，它会将分词分析出来的数组转化成树形的表达形式。同时，会验证语法，语法如果存在错误的话，会抛出语法错误。")]),t._v(" "),a("h4",{attrs:{id:"ast的具体应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ast的具体应用"}},[t._v("#")]),t._v(" AST的具体应用")]),t._v(" "),a("h5",{attrs:{id:"babel实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel实现原理"}},[t._v("#")]),t._v(" babel实现原理")]),t._v(" "),a("h5",{attrs:{id:"vue模板编译过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue模板编译过程"}},[t._v("#")]),t._v(" vue模板编译过程")]),t._v(" "),a("p",[t._v("将模板编译成render函数")]),t._v(" "),a("h5",{attrs:{id:"prettier实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prettier实现原理"}},[t._v("#")]),t._v(" Prettier实现原理")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844904019505184776",target:"_blank",rel:"noopener noreferrer"}},[t._v("babel，vue编译，Prettier等原理"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6854573222071894029#heading-3",target:"_blank",rel:"noopener noreferrer"}},[t._v("AST原理"),a("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{431:function(t,e,n){t.exports=n.p+"assets/img/3.0081fb45.png"},432:function(t,e,n){t.exports=n.p+"assets/img/2.2a48f305.png"},445:function(t,e,n){"use strict";n.r(e);var a=n(23),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"起步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#起步"}},[t._v("#")]),t._v(" 起步")]),t._v(" "),a("ol",[a("li",[t._v("创建项目 npx create-react-app myapp")]),t._v(" "),a("li",[t._v("打开项目: cd my-app")]),t._v(" "),a("li",[t._v("启动项目: npm start")]),t._v(" "),a("li",[t._v("暴露配置项: npm run eject 此方法不可逆")])]),t._v(" "),a("h3",{attrs:{id:"使用第三方组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用第三方组件"}},[t._v("#")]),t._v(" 使用第三方组件")]),t._v(" "),a("ul",[a("li",[t._v("安装: npm install antd --save")]),t._v(" "),a("li",[t._v("配置按需加载")])]),t._v(" "),a("p",[t._v("通过react脚手架create-react-app创建了项目，但是发现了一个问题 如果没有执行eject命令的话 是没有其他配置文件的 这个时候就需要 用到 customize-cra 和 react-app-rewired插件\n然后在根目录下新建一个名称为config-overrides.js的文件。在里面去进行所有的配置")]),t._v(" "),a("p",[a("code",[t._v("react-app-rewired的作用就是在不eject的情况下,覆盖create-react-app的配置")])]),t._v(" "),a("p",[t._v("babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件\n//引入\nconst { injectBabelPlugin } =require('react-app-rewired');\n//使用\nmodule.exports =function override(config, env){\nconfig= injectBabelPlugin(['import',\n{ libraryName:'antd', style:true}],config);\nreturn config;\n};")]),t._v(" "),a("p",[t._v("安装 react-app-rewired 取代 react-scripts，可扩展 webpack 的配置 ，类似 vue.config.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('npm install react-app-rewired customize-cra babel-plugin-import -D\n\n //根目录创建config-overrides.js\nconst { override, fixBabelImports } = require("customize-cra");\nmodule.exports = override(\nfixBabelImports("import", {\n    libraryName: "antd",\n    libraryDirectory: "es",\n    style: "css"\n}) );\n\n//修改package.json \n"scripts": {\n    "start": "react-app-rewired start",\n    "build": "react-app-rewired build",\n    "test": "react-app-rewired test",\n    "eject": "react-app-rewired eject"\n},\n')])])]),a("ul",[a("li",[a("p",[t._v("使用组件")]),t._v(" "),a("p",[t._v("import {Button} from 'antd'")])]),t._v(" "),a("li",[a("p",[t._v("使用sass")]),t._v(" "),a("p",[t._v("安装 npm install  node-sass --save-dev")])])]),t._v(" "),a("p",[t._v("因为create-react-app已经默认已经添加了scss/sass对应的loader，所以在安装完之后就可以在项目中使用scss了，详见配置可以参考\\node_modules\\react-scripts。")]),t._v(" "),a("ul",[a("li",[t._v("全局配置scss变量/函数")])]),t._v(" "),a("p",[t._v("在用scss预处理器的时候，会常用变量/函数/混合等功能。目前如果想要使用变量/函数的话需要在每个文件中单独引入，这样明显不合理，我们需要的是引入一次，所以我们就需要定义全局主题的样式变量，也就是利用sass-resources-loader这个loader将scss变量打包到每个文件中。首先我们要安装sass-resources-loader。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("npm install --save-dev sass-resources-loader\n")])])]),a("p",[t._v("不暴露配置文件情况下配置")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('const { override, adjustStyleLoaders } = require("customize-cra");\nmodule.exports = override(\n// ...其他配置...\n    adjustStyleLoaders(rule => {\n        if (rule.test.toString().includes("scss")) {\n        rule.use.push({\n            loader: require.resolve("sass-resources-loader"),\n            options: {\n            resources: "./src/assets/scss/output.scss" //这里是你自己放公共scss变量的路径\n            }\n        });\n        }\n})\n);\n')])])]),a("h3",{attrs:{id:"使用eslint-prettier来统一前端代码风格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用eslint-prettier来统一前端代码风格"}},[t._v("#")]),t._v(" 使用ESLint+Prettier来统一前端代码风格")]),t._v(" "),a("p",[t._v("编辑器vscode，并且已经安装好eslint和prettier插件\nESLint 进行代码的校验 Prettier 保持代码风格统一")]),t._v(" "),a("p",[t._v("npm i -D prettier  新建.eslintrc.js并在package.json里面删除eslintConfig")]),t._v(" "),a("p",[t._v("配合ESLint检测代码风格 npm i -D eslint-plugin-prettier")]),t._v(" "),a("p",[t._v("eslint-plugin-prettier插件会调用prettier对你的代码风格进行检查，其原理是先使用prettier对你的代码进行格式化，然后与格式化之前的代码进行对比，如果过出现了不一致，这个地方就会被prettier进行标记。")]),t._v(" "),a("p",[t._v('接下来，我们需要在rules中添加，"prettier/prettier": "error"，表示被prettier标记的地方抛出错误信息')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('//.eslintrc.js\n{\n"plugins": ["prettier"],\n"rules": {\n    "prettier/prettier": "error"\n}\n}\n')])])]),a("p",[t._v("如果与已存在的插件冲突怎么办")]),t._v(" "),a("p",[t._v("npm i -D eslint-config-prettier")]),t._v(" "),a("p",[t._v("通过使用eslint-config-prettier配置，能够关闭一些不必要的或者是与prettier冲突的lint选项。这样我们就不会看到一些error同时出现两次。使用的时候需要确保，这个配置在extends的最后一项")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('//.eslintrc.js\n{\n    extends: [\n        \'standard\', //使用standard做代码规范\n        "plugin:prettier/recommended",\n        "prettier",\n    ],\n\n}\n')])])]),a("p",[t._v("新建.prettierrc.js并添加")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("{\nsemi: true,\ntrailingComma: 'all',\nsingleQuote: true,\nprintWidth: 120,\ntabWidth: 4,\n}\n")])])]),a("p",[t._v("添加commit命令 npm install --save lint-staged husky\n修改package.json")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('"lint-staged": {\n    "*.+(js|jsx)": [\n        "eslint --fix",\n        "git add"\n    ],\n    "*.+(json|css|md)": [\n        "prettier --write",\n        "git add"\n    ]\n},\n"husky": {\n    "hooks": {\n        "pre-commit": "lint-staged"\n    }\n},\n')])])]),a("h3",{attrs:{id:"cra-文件结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cra-文件结构"}},[t._v("#")]),t._v(" cra ⽂件结构")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("├── README.md             文档\n├── public                静态资源\n│ ├── favicon.ico\n│ ├── index.html\n│ └── manifest.json\n└── src                   源码\n├── App.css\n├── App.js                根组件\n├── App.test.js\n├── index.css             全局样式\n├── index.js              入⼝文件\n├── logo.svg\n└── serviceWorker.js      pwa 支持\n├── package.json          npm 依赖\n")])])]),a("h3",{attrs:{id:"入口文件定义-webpack-config-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#入口文件定义-webpack-config-js"}},[t._v("#")]),t._v(" ⼊口文件定义，webpack.config.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("entry: [\n// WebpackDevServer 客户端，它实现开发时热更更新功能\nisEnvDevelopment && require.resolve('react-dev-utils/webpackHotDevClient'),\n// 应⽤用程序⼊入⼝口:src/index\npaths.appIndexJs,\n].filter(Boolean),\n")])])]),a("p",[t._v("webpack.config.js 是 webpack 配置⽂文件，开头的常量量声明可以看出 cra 能够⽀支持 ts、sass 及 css 模块化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("// Check if TypeScript is setup\nconst useTypeScript = fs.existsSync(paths.appTsConfig);\n// style files regexes\nconst cssRegex = /\\.css$/;\nconst cssModuleRegex = /\\.module\\.css$/;\nconst sassRegex = /\\.(scss|sass)$/;\nconst sassModuleRegex = /\\.module\\.(scss|sass)$/;\n")])])]),a("h3",{attrs:{id:"react-和-reactdom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-和-reactdom"}},[t._v("#")]),t._v(" React 和 ReactDom")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("import React from 'react';\nimport ReactDOM from 'react-dom';\n// 这⾥里里怎么没有出现React字眼?\n// JSX => React.createElement(...)\nReactDOM.render(<h1>Hello React</h1>, document.querySelector('#root'));\nReact负责逻辑控制，数据 -> VDOM\nReactDom渲染实际DOM VDOM -> DOM\nReact使⽤用JSX来描述UI\nbabel-loader把JSX 编译成相应的 JS 对象，\nReact.createElement再把这个JS对象构造成React需 要的虚拟dom。\n")])])]),a("h3",{attrs:{id:"jsx-语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx-语法"}},[t._v("#")]),t._v(" JSX 语法")]),t._v(" "),a("p",[t._v("JSX 是一种 JavaScript 的语法扩展，其格式比较像模版语言，但事实上完全 是在 JavaScript 内部实现的。\n"),a("br"),t._v("\nJSX 可以很好地描述 UI，能够有效提高开发效率，体验 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JSX"),a("OutboundLink")],1)]),t._v(" "),a("h4",{attrs:{id:"基本使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本使用"}},[t._v("#")]),t._v(" 基本使用")]),t._v(" "),a("p",[t._v("表达式{}的使用，index.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('const name = "react study";\nconst jsx = <div>hello, {name}</div>;\n')])])]),a("h4",{attrs:{id:"函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),a("p",[t._v("函数也是合法表达式，index.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('const user = {\n    fistName: "Harry",\n};\nfunction formatName(name) {\n    return name.fistName + " " + name.lastName;\n}\nconst jsx = <div>{formatName(user)}</div>;\n')])])]),a("h4",{attrs:{id:"对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[t._v("#")]),t._v(" 对象")]),t._v(" "),a("p",[t._v("jsx 是 js 对象，也是合法表达式，index.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("const greet = <div>good</div>;\nconst jsx = <div>{greet}</div>;\n")])])]),a("h4",{attrs:{id:"条件语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件语句"}},[t._v("#")]),t._v(" 条件语句")]),t._v(" "),a("p",[t._v("条件语句可以基于上面结论实现，index.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('const show = true;//false;\nconst greet = <div>good</div>;\nconst jsx = (\n<div>\n// 条件语句\n{show ? greet : "登录"} {show && greet}\n</div>\n);\n')])])]),a("h4",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("p",[t._v("数组会被作为一组子元素对待，数组中存放一组 jsx 可用于显示列表数据")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("const a = [0, 1, 2];\nconst jsx = (\n<div>\n //数组\n  <ul>\n//diff 时候，首先比较 type，然后是 key，所以同级同类型元素， key 值必须得 唯一\n{a.map(item => (\n<li key={item}>{item}</li>\n))}\n</ul> </div>\n);\n")])])]),a("h4",{attrs:{id:"属性的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性的使用"}},[t._v("#")]),t._v(" 属性的使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('import logo from "./logo.svg";\n\nconst jsx=(\n    <img src={logo} style={{ width: "100px" , height:"100px",background:"#000"} className="img"/>\n)\n')])])]),a("h4",{attrs:{id:"模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),a("p",[t._v("css 模块化，创建 index.module.css，index.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('import style from "./index.module.css";\n<img className={style.logo} />\n')])])]),a("p",[t._v("或者 npm install sass -D")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('import style from "./index.module.scss";\n<img className={style.logo} />\n')])])]),a("h2",{attrs:{id:"setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),a("p",[t._v("setState(partialState, callback)")]),t._v(" "),a("ol",[a("li",[t._v("partialState:object|function\n"),a("br"),t._v("\n⽤于产⽣与当前 state 合并的子集。")]),t._v(" "),a("li",[t._v("callback:function\n"),a("br"),t._v("\nstate 更更新之后被调⽤用。")])]),t._v(" "),a("h3",{attrs:{id:"关于-setstate-你应该了了解三件事"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于-setstate-你应该了了解三件事"}},[t._v("#")]),t._v(" 关于 setState() 你应该了了解三件事:")]),t._v(" "),a("p",[t._v("1.不要直接修改 State")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("//此代码不会重新渲染组件:\nthis.state.name='erdang'\n//正确\nthis.setState({name:'erdang'})\n")])])]),a("p",[t._v("2.State 的更更新会被合并")]),t._v(" "),a("p",[a("strong",[t._v("出于性能考虑，React 可能会把多个 setState() 调用合并成⼀个调用")])]),t._v(" "),a("p",[t._v("批量操作：对同一个 key 多次操作会合并，会执行最后一次")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("changeValue = v => {\n    this.setState({\n        counter: this.state.counter + v\n    });\n};\nsetCounter = () => {\n    this.changeValue(1);\n    this.changeValue(2);\n};\n\n如果想要链式更更新state:\n\nchangeValue = v => {\n    this.setState(state => ({ counter: state.counter + v }));\n};\nsetCounter = () => {\n    this.changeValue(1);\n    this.changeValue(2);\n};\n")])])]),a("p",[t._v("3.State 的更新可能是异步的")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("class Clock extends Component {\n\nstate = { date: new Date(), counter: 1 };\n\ncomponentDidMount() {\n    this.timer = setInterval(() => {\n    //   setState修改状态\n    this.setState({ date: new Date() });\n    }, 1000);\n\n    // 批量操作：对同一个key多次操作会合并，会执行最后一次\n    this.setState({ counter: this.state.counter + 1 });\n    this.setState({ counter: this.state.counter + 1 });\n    this.setState({ counter: this.state.counter + 1 }, ()=>{\n        console.log('cb'+this.state.counter); // 2 在回调中获取状态值\n    });\n    console.log(this.state.counter); // 1\n\n    this.setState(prev => {\n    console.log(prev.counter); // 2\n    return prev.counter;\n    });\n\n    setTimeout(() => {\n        console.log(this.state.counter); // 2 使⽤用定时器器:\n    }, 0);\n\n    document.body.addEventListener(\"click\", this.changeCounter); //原⽣生事件中修改状态\n}\n\nchangeCounter = () => {\n    this.setState({ counter: this.state.counter + 1 });\n    console.log(this.state.counter); // 3\n};\n\ncomponentWillUnmount() {\n    clearInterval(this.timer);\n}\n\nrender() {\n    return (\n    <div>\n        {this.state.date.toLocaleTimeString()}\n        <p>{this.state.counter}</p>\n    </div>\n    );\n}\n}\n")])])]),a("p",[t._v("如果要获取到最新状态值有以下⽅方式:")]),t._v(" "),a("ol",[a("li",[t._v("在回调中获取状态值")]),t._v(" "),a("li",[t._v("使⽤用定时器器:")]),t._v(" "),a("li",[t._v("原⽣事件中修改状态")])]),t._v(" "),a("p",[t._v("setState 只有在合成事件和⽣命周期函数中是异步的，react 基本都是合成事件"),a("br"),t._v("\n在原⽣事件和 setTimeout 中都是同步 的，这⾥的异步其实是批量更新。")]),t._v(" "),a("h2",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("h3",{attrs:{id:"react-v16-3-之前的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-v16-3-之前的生命周期"}},[t._v("#")]),t._v(" React V16.3 之前的生命周期")]),t._v(" "),a("p",[a("img",{attrs:{src:n(431),alt:"1"}})]),t._v(" "),a("h3",{attrs:{id:"react-v16-4-之后的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-v16-4-之后的生命周期"}},[t._v("#")]),t._v(" React V16.4 之后的生命周期")]),t._v(" "),a("p",[a("img",{attrs:{src:n(432),alt:"2"}})]),t._v(" "),a("p",[t._v("引入两个新的生命周期\nstatic getDerivedStateFromProps "),a("br"),t._v("\ngetSnapshotBeforeUpdate")]),t._v(" "),a("h4",{attrs:{id:"挂载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#挂载"}},[t._v("#")]),t._v(" 挂载")]),t._v(" "),a("p",[t._v("当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1.constructor()\n2.static getDerivedStateFromProps()\n3.render()\n4.componentDidMount()\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("下述生命周期方法即将过时，在新代码中应该避免使用它们：\nUNSAFE_componentWillMount()")])]),t._v(" "),a("h4",{attrs:{id:"更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),a("p",[t._v("当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1.static getDerivedStateFromProps()\n2.shouldComponentUpdate()\n3.render()\n4.getSnapshotBeforeUpdate()\n5.componentDidUpdate()\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("下述方法即将过时，在新代码中应该避免使用它们："),a("br"),t._v("\nUNSAFE_componentWillUpdate()"),a("br"),t._v("\nUNSAFE_componentWillReceiveProps()")])]),t._v(" "),a("h4",{attrs:{id:"卸载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#卸载"}},[t._v("#")]),t._v(" 卸载")]),t._v(" "),a("p",[t._v("当组件从 DOM 中移除时会调用如下方法：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("componentWillUnmount()\n")])])]),a("h4",{attrs:{id:"错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[t._v("#")]),t._v(" 错误处理")]),t._v(" "),a("p",[t._v("当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("static getDerivedStateFromError()\ncomponentDidCatch()\n")])])]),a("h3",{attrs:{id:"render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[t._v("#")]),t._v(" render()")]),t._v(" "),a("p",[t._v("class 组件中唯一必须实现的方法。"),a("br"),t._v("\nrender() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，"),a("br"),t._v("\n每次调用时都返回相同的结果，并且它不会直接与浏览器交互。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("如果 shouldComponentUpdate() 返回 false，则不会调用 render()")])]),t._v(" "),a("h3",{attrs:{id:"constructor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor()")]),t._v(" "),a("p",[t._v("在 React 组件挂载之前，会调用它的构造函数。"),a("br"),t._v("\n在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 super(props)。"),a("br"),t._v("\n否则，this.props 在构造函数中可能会出现未定义的 bug"),a("br")]),t._v(" "),a("p",[t._v("通常，在 React 中，构造函数仅用于以下两种情况："),a("br")]),t._v(" "),a("p",[t._v("1.通过给 this.state 赋值对象来初始化内部 state。"),a("br"),t._v(" 2.为事件处理函数绑定实例")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("constructor(props) {\nsuper(props);\n// 不要在这里调用 this.setState()\nthis.state = { counter: 0 };\nthis.handleClick = this.handleClick.bind(this);\n}\n")])])]),a("h3",{attrs:{id:"componentdidmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentdidmount"}},[t._v("#")]),t._v(" componentDidMount()")]),t._v(" "),a("p",[t._v("componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。")]),t._v(" "),a("p",[t._v("这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅")]),t._v(" "),a("p",[t._v("你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理")]),t._v(" "),a("h3",{attrs:{id:"componentdidupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentdidupdate"}},[t._v("#")]),t._v(" componentDidUpdate()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("componentDidUpdate(prevProps, prevState, snapshot)\n")])])]),a("p",[t._v("componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法")]),t._v(" "),a("p",[t._v("当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("componentDidUpdate(prevProps) {\n// 典型用法（不要忘记比较 props）：\n    if (this.props.userID !== prevProps.userID) {\n        this.fetchData(this.props.userID);\n    }\n}\n")])])]),a("p",[t._v("如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。")]),t._v(" "),a("h3",{attrs:{id:"componentwillunmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillunmount"}},[t._v("#")]),t._v(" componentWillUnmount()")]),t._v(" "),a("p",[t._v("componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。")]),t._v(" "),a("h3",{attrs:{id:"shouldcomponentupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate"}},[t._v("#")]),t._v(" shouldComponentUpdate()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("shouldComponentUpdate(nextProps, nextState)\n")])])]),a("p",[t._v("根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。"),a("br"),t._v("\n默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。"),a("br")]),t._v(" "),a("p",[t._v("当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。"),a("br"),t._v("\n返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。")]),t._v(" "),a("p",[a("code",[t._v("此方法仅作为性能优化的方式而存在。")]),t._v("不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。")]),t._v(" "),a("p",[t._v("如果你一定要手动编写此函数，可以将 this.props 与 nextProps 以及 this.state 与 nextState 进行比较，并返回 false 以告知 React 可以跳过更新。请注意，返回 false 并不会阻止子组件在 state 更改时重新渲染。")]),t._v(" "),a("p",[t._v("我们不建议在 shouldComponentUpdate() 中进行深层比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能")]),t._v(" "),a("h3",{attrs:{id:"static-getderivedstatefromprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static-getderivedstatefromprops"}},[t._v("#")]),t._v(" static getDerivedStateFromProps()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("static getDerivedStateFromProps(props, state)\n")])])]),a("p",[t._v("getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。")]),t._v(" "),a("h3",{attrs:{id:"getsnapshotbeforeupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getsnapshotbeforeupdate"}},[t._v("#")]),t._v(" getSnapshotBeforeUpdate()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("getSnapshotBeforeUpdate(prevProps, prevState)\n")])])]),a("p",[t._v("getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。")]),t._v(" "),a("p",[t._v("此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。")]),t._v(" "),a("p",[t._v("应返回 snapshot 的值（或 null）。")]),t._v(" "),a("h3",{attrs:{id:"static-getderivedstatefromerror"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static-getderivedstatefromerror"}},[t._v("#")]),t._v(" static getDerivedStateFromError()")]),t._v(" "),a("p",[t._v("此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state\n当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI")]),t._v(" "),a("h3",{attrs:{id:"componentdidcatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentdidcatch"}},[t._v("#")]),t._v(" componentDidCatch()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("componentDidCatch(error, info)\n")])])]),a("p",[t._v("此生命周期在后代组件抛出错误后被调用。 它接收两个参数：")]),t._v(" "),a("p",[t._v("使用 componentDidCatch() 打印错误信息。\nerror —— 抛出的错误。\ninfo —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。\ncomponentDidCatch() 会在“提交”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况：")]),t._v(" "),a("h2",{attrs:{id:"事件处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件处理"}},[t._v("#")]),t._v(" 事件处理")]),t._v(" "),a("p",[t._v("React 事件的命名采用小驼峰式（camelCase），而不是纯小写。")]),t._v(" "),a("p",[t._v("使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("class LoggingButton extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {isToggleOn: true};\n\n        // 为了在回调中使用 `this`，这个绑定是必不可少的\n        this.handleClick = this.handleClick.bind(this);\n    }\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    // 注意: 这是 *实验性* 语法。\n    handleClick = () => {\n        console.log('this is:', this);\n    }\n    handleClick() {\n        console.log('this is:', this);\n    }\n\n    render() {\n        // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n        return (\n        <button onClick={() => this.handleClick()}>\n            Click me\n        </button>\n        //React 的事件对象 e 会被作为第二个参数传递。在这里，e 是一个合成事件。如果通过箭头函数的方式，\n        事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。\n        <button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n        <button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n        );\n    }\n}\n")])])]),a("h2",{attrs:{id:"条件渲染-列表-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件渲染-列表-key"}},[t._v("#")]),t._v(" 条件渲染 列表 & Key")]),t._v(" "),a("p",[t._v("如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题")]),t._v(" "),a("h2",{attrs:{id:"表单"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表单"}},[t._v("#")]),t._v(" 表单")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('<input type="text">, <textarea> 和 <select> 之类的标签都\n非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件\n<input type="file" /> 它的 value 只读，所以它是 React 中的一个非受控组件\n\n处理多个输入\n当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，\n并让处理函数根据 event.target.name 的值选择要执行的操作\nhandleInputChange(event) {\n    const target = event.target;\n    const value = target.type === \'checkbox\' ? target.checked : target.value;\n    const name = target.name;\n\n    this.setState({\n    [name]: value\n    });\n}\n')])])]),a("h2",{attrs:{id:"组件-组件复合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件-组件复合"}},[t._v("#")]),t._v(" 组件 组件复合")]),t._v(" "),a("p",[t._v("组件有两种形式:class 组件和 function 组件。 组件命名首字母大写 MyComponent")]),t._v(" "),a("h3",{attrs:{id:"class-组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-组件"}},[t._v("#")]),t._v(" class 组件")]),t._v(" "),a("p",[t._v("class 组件通常拥有状态和⽣命周期，继承于 Component，实现 render ⽅法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("class Abc extends React.Component{\n\n    render() {\n        return <div>{this.state.date.toLocaleTimeString()}</div>;\n    }\n\n}\n")])])]),a("h3",{attrs:{id:"function-组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-组件"}},[t._v("#")]),t._v(" function 组件")]),t._v(" "),a("p",[t._v("函数组件通常无状态，仅关注内容展示，返回渲染结果即可。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("从 React16.8 开始引⼊入了了 hooks，函数组件也能够拥有状态")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('import React, { useState, useEffect } from "react";\nexport function FunctionComponent(props) {\n\n    const [date, setDate] = useState(new Date());\n\n    useEffect(() => {//副作⽤用\n        const timer = setInterval(() => {\n            setDate(new Date());\n        }, 1000);\n        return () => clearInterval(timer);//组件卸载的时候执⾏\n    }, []);\n\nreturn (\n    <div>\n    <h3>FunctionComponent</h3>\n    <p>{date.toLocaleTimeString()}</p>\n    </div>\n); }\n')])])]),a("h3",{attrs:{id:"复合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复合"}},[t._v("#")]),t._v(" 复合")]),t._v(" "),a("p",[t._v("不具名")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('import React, { Component } from "react";\nimport TopBar from "../components/TopBar";\nimport BottomBar from "../components/BottomBar";\n\nexport default class Layout extends Component {\n    componentDidMount() {\n        const { title = "商城" } = this.props;\n        document.title = title;\n    }\n     render() {\n        const { children, showTopBar, showBottomBar } = this.props;\n        console.log("children", children);\n        return (\n        <div>\n            {showTopBar && <TopBar />}\n            {children.content}\n            {children.txt}\n            <button onClick={children.btnClick}>button</button>\n            {showBottomBar && <BottomBar />}\n        </div>\n    ); }\n}\n\nimport React, { Component } from "react";\nimport Layout from "./Layout";\n\nexport default class UserPage extends Component {\nrender() {\n    return (\n    <Layout showTopBar={true} showBottomBar={true} title="⽤用户中⼼心">\n            <div>\n            <h3>UserPage</h3>\n            </div>\n        </Layout>\n    ); }\n}\n')])])]),a("p",[t._v("具名")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("import React, { Component } from 'react'\n\nfunction Formbutton(props) {\n    return <div className=\"Formbutton\">\n        <button onClick={props.children.defaultBtns.searchClick}>默认查询</button> <button onClick={props.children.defaultBtns.resetClick}>默认重置</button>\n    {\n        props.children.btns.map((item, index) => {\n            return <button key={'btn' + index} onClick={item.onClick}>{item.title}</button>\n        })\n\n    }\n    </div>\n}\n\n\n<Formbutton>\n    {\n        {\n            defaultBtns:{\n                searchClick: () => console.log('默认查询'),\n                resetClick: () => console.log('默认重置')\n            }\n        }\n    }\n</Formbutton>\n\nReact.Children.map(props.children, child=>child.type==='p')\n类似的还有React.Children.forEach，React.Children.toArray等\n")])])]),a("h2",{attrs:{id:"高阶组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),a("p",[t._v("高阶组件 HOC(Higher-Order Components)是 React 中重用组件逻辑的高级技术， "),a("br"),t._v("\n它不是 react 的 api，而是一种 组件增强模式。高阶组件是一个函数，它返回另外一个组件，"),a("br"),t._v("\n产生新的组件可以对被包装组件属性进行包装，也可 以重写部分生命周期")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('const withKaikeba = (Component) => {\n    const NewComponent = (props) => {\n    return <Component {...props} name="高阶组件" />; };\n    return NewComponent;\n};\n')])])]),a("h3",{attrs:{id:"链式调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链式调用"}},[t._v("#")]),t._v(" 链式调用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('const withLog = Component=>{\nclass NewComponent extends React.Component{\n    render(){\n        return <Component {...this.props} />;\n    }\n    componentDidMount(){\n        console.log(\'didMount\',this.props)\n    }\n}\nreturn NewComponent\n}\nclass App extends Component {\n    render() {\n        return (\n        <div className="App">\n        <h2>hi,{this.props.name}</h2>\n            <Button type="primary">Button</Button>\n        </div>\n    ) }\n    }\nexport default withKaikeba(withLog(App))\n')])])]),a("h3",{attrs:{id:"装饰器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰器"}},[t._v("#")]),t._v(" 装饰器")]),t._v(" "),a("p",[t._v("ES7 中有一个优秀的语法—装饰器 ，可使代码更简洁")]),t._v(" "),a("p",[t._v("npm install -D @babel/plugin-proposal-decorators")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('const { addDecoratorsLegacy } = require("customize-cra");\nmodule.exports = override(\n    ...,\n    addDecoratorsLegacy()\n);\n\n// 应用\nconst withLog = Component=>{...}\nconst withKaikeba = Component=>{...}\n@withKaikeba\n@withLog\nclass App extends Component {\nrender() {\n    return (\n    <div className="App">\n    <h2>hi,{this.props.name}</h2>\n        <Button type="primary">Button</Button>\n    </div>\n) }\n}\nexport default App\n')])])]),a("h2",{attrs:{id:"react-createelement-与-react-cloneelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-createelement-与-react-cloneelement"}},[t._v("#")]),t._v(" React.createElement() 与 React.cloneElement()")]),t._v(" "),a("p",[t._v("React.createElement()： 根据指定的第一个参数创建一个 React 元素。\n第三个参数可以分开也可以写成一个数组")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("React.createElelment(type,[props],[...children])\n第一个参数是必填，传入的是似HTML标签名称，eg: ul, li\n第二个参数是选填，表示的是属性，eg: className\n第三个参数是选填, 子节点，eg: 要显示的文本内容\n\nvar child1 = React.createElement('li', null, 'one');\nvar child2 = React.createElement('li', null, 'two');\nReact.createElement('ul', { className: 'teststyle' }, child1, child2)\nReact.createElement('ul', { className: 'teststyle' }, [child1, child2])\n")])])]),a("p",[t._v("React.cloneElement() 克隆并返回一个新的 ReactElement （内部子元素也会跟着克隆），"),a("br"),t._v("\n新返回的元素会保留有旧元素的 props、ref、key，也会集成新的 props（只要在第二个参数中有定义）。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("React.cloneElement(element,[props],[...children])\n\nrenderChildren() {\n    return React.Children.map(this.props.children, child => {\n        return React.cloneElement(child, {\n            name: this.props.name\n        })\n    })\n}\n")])])]),a("h2",{attrs:{id:"purecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent"}},[t._v("#")]),t._v(" PureComponent")]),t._v(" "),a("p",[t._v("定制了 shouldComponentUpdate 后的 Component,"),a("code",[t._v("必须要用class形式，⽽且要注意是浅⽐较")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层⽐较,浅层对⽐ prop 和 state 。\n如果对象中 包含复杂的数据结构，则有可能因为⽆法检查深层的差别，产⽣生错误的⽐对结果。\n仅在你的 props 和 state 较为简单时，才使⽤用 React.PureComponent ，\n或者在深层数据结构发生变化时 调⽤用 forceUpdate() 来确保组件被正确地更新。\n你也可以考虑使⽤ immutable 对象加速嵌套数据的比较。\n此外， React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop\n更新。因此，请确保所有⼦组件也都是“纯”的组件\n")])])]),a("h2",{attrs:{id:"react-memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-memo"}},[t._v("#")]),t._v(" React.memo")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("React 16.6.0 使用 React.memo 让函数式的组件也有PureComponent的功能\nconst Joke = React.memo(() => (\n    <div>\n        {this.props.value || 'loading...' }\n    </div>\n));\n")])])]),a("h2",{attrs:{id:"fragments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragments"}},[t._v("#")]),t._v(" Fragments")]),t._v(" "),a("p",[t._v("Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点 简写<></>")]),t._v(" "),a("h2",{attrs:{id:"context-组件跨层级通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context-组件跨层级通信"}},[t._v("#")]),t._v(" Context 组件跨层级通信")]),t._v(" "),a("p",[t._v("vuejs 的 privide&inject 模式的来源---context\n这种模式下有两个角色:\n-Provider:外层提供数据的组件\n-Consumer :内层获取数据的组件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("const FormContext = React.createContext()\nconst FormProvider = FormContext.Provider\nconst FormConsumer = FormContext.Consumer\nconst store ={ name:'erdang'}\nclass ContextTest extends Component {\n    render() {\n        return <FormProvider value={store}>\n        <FormConsumer>\n            {store=><p>{store.name}</p>}\n        </FormConsumer>\n        </FormProvider>\n    }\n}\n")])])]),a("h2",{attrs:{id:"refs-and-the-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#refs-and-the-dom"}},[t._v("#")]),t._v(" Refs and the DOM")]),t._v(" "),a("p",[t._v("何时使用 Refs")]),t._v(" "),a("ul",[a("li",[t._v("管理焦点，文本选择或媒体播放。")]),t._v(" "),a("li",[t._v("触发强制动画。")]),t._v(" "),a("li",[t._v("集成第三方 DOM 库。")])]),t._v(" "),a("p",[t._v("Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("class MyComponent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.myRef = React.createRef();\n    }\n    render() {\n        return <div ref={this.myRef} />;\n    }\n}\n\nconst node = this.myRef.current;\n//挂载到dom 上就是dom元素   挂载的组件 就是组件实例\n")])])]),a("p",[t._v("函数组件 ref")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('function CustomTextInput(props) {\n// 这里必须声明 textInput，这样 ref 才可以引用它\nconst textInput = useRef(null);\n\nfunction handleClick() {\n    textInput.current.focus();\n}\n\nreturn (\n    <div>\n    <input\n        type="text"\n        ref={textInput} />\n    <input\n        type="button"\n        value="Focus the text input"\n        onClick={handleClick}\n    />\n    </div>\n)\n')])])]),a("p",[t._v("回调 ref")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('class CustomTextInput extends React.Component {\n    constructor(props) {\n        super(props);\n        this.textInput = null;\n        this.setTextInputRef = element => {\n            this.textInput = element;\n        };\n\n        this.focusTextInput = () => {\n            // 使用原生 DOM API 使 text 输入框获得焦点\n            if (this.textInput) this.textInput.focus();\n        };\n    }\n\n    componentDidMount() {\n        // 组件挂载后，让文本框自动获得焦点\n        this.focusTextInput();\n    }\n\n    render() {\n        // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React\n        // 实例上（比如 this.textInput）\n        return (\n        <div>\n            <input\n            type="text"\n            ref={this.setTextInputRef}\n            />\n            <input\n            type="button"\n            value="Focus the text input"\n            onClick={this.focusTextInput}\n            />\n        </div>\n        );\n    }\n}\n')])])]),a("h3",{attrs:{id:"react-forwardref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-forwardref"}},[t._v("#")]),t._v(" React.forwardRef")]),t._v(" "),a("p",[t._v("你可能希望在父组件中引用子节点的 DOM 节点 转发")]),t._v(" "),a("p",[t._v("Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('const FancyButton = React.forwardRef((props, ref) => (\n<button ref={ref} className="FancyButton">\n    {props.children}\n</button>\n));\n\n// 你可以直接获取 DOM button 的 ref：\nconst ref = React.createRef();\n<FancyButton ref={ref}>Click me!</FancyButton>;\n\n1.我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。\n2.我们通过指定 ref 为 JSX 属性，将其向下传递给 <FancyButton ref={ref}>。\n3.React 传递 ref 给 forwardRef 内函数 (props, ref) => ...，作为其第二个参数。\n4.我们向下转发该 ref 参数到 <button ref={ref}>，将其指定为 JSX 属性。\n5.当 ref 挂载完成，ref.current 将指向 <button> DOM 节点。\n')])])]),a("p",[t._v("在高阶组件中转发 refs "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/forwarding-refs.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("高阶组件转发"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"portals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#portals"}},[t._v("#")]),t._v(" Portals")]),t._v(" "),a("p",[t._v("Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("ReactDOM.createPortal(child, container)\n第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。\n第二个参数（container）是一个 DOM 元素。\n")])])]),a("h2",{attrs:{id:"render-props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-props"}},[t._v("#")]),t._v(" Render Props")]),t._v(" "),a("p",[t._v("一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术")]),t._v(" "),a("p",[t._v("具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("<DataProvider render={data => (\n    <h1>Hello {data.target}</h1>\n)}/>\n")])])]),a("h2",{attrs:{id:"strictmode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#strictmode"}},[t._v("#")]),t._v(" StrictMode")]),t._v(" "),a("p",[t._v("StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。")]),t._v(" "),a("p",[t._v("它为其后代元素触发额外的检查和警告。")]),t._v(" "),a("h2",{attrs:{id:"proptypes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proptypes"}},[t._v("#")]),t._v(" PropTypes")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("import PropTypes from 'prop-types'\n\nfunction HelloWorldComponent({ name }) {\nreturn (\n    <div>Hello, {name}</div>\n)\n}\n\nHelloWorldComponent.propTypes = {\nname: PropTypes.string\n}\n\nexport default HelloWorldComponent\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);